[{"content":"0 GMX项目发展史 在2020年10月，xvi10启动了 xvix-contracts 项目，并部署到了Ethereum Mainnet。 在2021年3月，xvi10把 xvix-contracts 升级为 gambit-contracts ，并部署到了BSC。 在2021年9月，xvi10基于 gambit-contracts 启动GMX项目，并部署到了Arbitrum One。 在启动一周后，GMX完成了第一次升级，在eth、wbtc和usdc的基础上，添加了link、uni和usdt。 在启动三个月后，GMX，完成了第二次升级，部署到了Avalanche链上。\n1 GMX的产品设计目标 GMX的产品设计目标是打造一个去中心化的永续合约和现货交易平台。不需要任何注册、KYC和地域限制等限制，用户即可方便地用它进行链上资产交易和合约交易。\n2 GMX的核心卖点  去中心化。GMX是一个去中心化的永续合约交易平台，所有资产由智能合约保管，智能合约开源，所有运营数据也是公开透明的。 全额保证金。GMX上面的所有杠杆订单都是有全额保证金的，保障用户的收益能够钢性对付，很多中心化交易所都无法做到全额保证金。 无需许可Permissionless。所有人都可以公平得参与平台做市，并且根据GMX和GLP持有量平等地分到平台的盈利。 市场报价去中心化。系统报价主要由ChainLink和报价机器人组成，报价公开透明，有效避免了恶意插针等扰乱市场的行为。  3 GMX的系统整体设计 3.1 GMX系统架构图 其中，Vault合约是整个GMX的核心，负责管理GMX平台的全部资产。\n3.2 系统核心数据模型 { \t\u0026#34;id\u0026#34;: keccak256(_account, _collateralToken, _indexToken, _isLong), // 仓位ID \t\u0026#34;size\u0026#34;: uint256, // Position大小 \t\u0026#34;collateral\u0026#34;: uint256, // 抵押品价格 USD \t\u0026#34;averagePrice\u0026#34;: uint256, // 平均持仓价格 USD \t\u0026#34;entryFundingRate\u0026#34;: uint256, // 入场资金费率 \t\u0026#34;reserveAmount\u0026#34;: uint256, // 抵押品token储备数量 \t\u0026#34;realisedPnl\u0026#34;: int256, // 已兑付盈亏 \t\u0026#34;lastIncreasedTime\u0026#34;: uint256, // 最后加仓时间 } 盈亏USD价值计算：\ndelta = position.size * (currentPrice - position.averagePrice) / position.averagePrice 4 GMX核心业务逻辑解读 了解了GMX系统设计框架，那么解析来就逐个解析它的核心业务流程。\n4.1 GMX加减仓业务逻辑 4.1.1 GMX加减仓业务流程 创建订单流程\n 用户在Web页面发起市价或者限价单，并发送Transaction到链上。 Transaction会根据用户的提交参数，选择调用市价单或者限价单合约来创建订单。 结束，等待交易机器人执行交易。  执行订单流程\n 执行交易机器人根据市场价选择执行市价单或者限价单，并发送交易到链上。 Transaction会根据会根据机器人的提交参数，选择调用市价单或者限价单合约和执行订单。 市价单或者限价单合约会调用Vault合约来执行加减仓操作。  4.1.2 GMX加减仓流程解读 从加减仓业务流程中可以看出，订单的创建和执行是2个独立的步骤。首先，用户创建市价单和限价单，并由市价单合约和限价单合约来保存订单数据。然后，订单执行机器人会异步调用市价单合约和限价单合约来执行订单。订单执行机器人可以根据当前的市价选择哪些订单可以被执行。\n手续费 = 交易手续费 + 资金费用\n 交易手续费：价减仓USD金额 * 0.1%。 资金费用：仓位总USD价值 * 时间间隔 * 单位USD单位时间间隔的费率。  爆仓条件 另外还需要判断是否爆仓，满足一下条件之一就有可能爆仓。\n 条件一：抵押品总USD价值 + 仓位盈亏USD价值 \u0026lt; 资金USD费用 + 清算USD费用。 条件二：(抵押品总USD价值 + 仓位盈亏USD价值) * 最大杠杆倍数 \u0026lt; 仓位总USD价值。 其中，清算USD费用由管理员设置。  相关合约地址\n   合约名称 合约地址     市价单合约 0xb87a436b93ffe9d75c5cfa7bacfff96430b09868   限价单合约 0x09f77e8a13de9a35a7231028187e9fd5db8a2acb   Vault合约 0x489ee077994b6658eafa855c308275ead8097c4a    相关交易操作交易Hash\n   操作名称 交易Hash     用户发起市价单加仓交易 0x3230e702a44c6029790d279d0a11e87f89474a9fec251aa0b7f5070aab38104b   用户发起市价单减仓交易 0x7d359cb6a1744f87c6b4cc1ff93a8b8ee9fc6bbfa73227e8c7d8b59214a8a368   执行机器人执行市价单 0x5f5a3a90ed30b099ad456f14e7ea580cea3f25cd4bdf2d491ae5e18eadd87ff2   执行机器人执行限价单 0x3cc5b3bd1fc5efeba0cbf1cfc5752773d9476c15b2fb8cc3bb5dc02b8480b5af    4.2 GMX清算业务逻辑 4.2.1 GMX清算业务流程 清算流程\n 清算机器人发送清算交易，并广播到链上 仓位管理合约调用Vault合约执行清算逻辑  4.2.2 GMX清算流程解读 清算流程主要清算机器人来发起，清算机器人会监控合约中的Position，并调用合约方法来对爆仓的Position进行清算。完成清算任务后，清算机器人收到一笔清算手续费。\n仓位清算条件 满足一下条件之一就可以被清算\n 条件一：抵押品总USD价值 + 仓位盈亏USD价值 \u0026lt; 资金USD费用 + 清算USD费用 条件二：(抵押品总USD价值 + 仓位盈亏USD价值) * 最大杠杆倍数 \u0026lt; 仓位总USD价值 其中，清算USD费用大小由管理员设置。  相关合约地址\n   合约名称 合约地址     仓位管理合约 0x75e42e6f01baf1d6022bea862a28774a9f8a4a0c   Vault合约 0x489ee077994b6658eafa855c308275ead8097c4a    相关交易操作交易Hash\n   操作名称 交易Hash     清算机器人发起清算流程 0xccca7adf093d4e20ed25d2d479419a1efaac964c337beea958f214b4db195c34    4.3 GMX现货交易业务逻辑 4.3.1 GMX现货交易业务流程 现货交易流程\n 用户发起现货交易，并广播到链上。 Router合约调用Vault合约执行现货交易。 Vault合约从Token价格合约获取价格，并执行交易  4.3.2 GMX现货交易流程解读 GMX的现货交易不是主流的AMM，而是通过Chainlink获取TokenIn价格，然后计算出TokenOut的数量。具体计算过程如下\n 先从Token价格合约获取tokenInUSDPrice和tokenOutUSDPrice。 计算tokenOutAmount：tokenOutAmount = tokenInAmount * tokenInUSDPrice / tokenOutUSDPrice。  相关合约地址\n   合约名称 合约地址     Router合约 0xabbc5f99639c9b6bcb58544ddf04efa6802f4064   Vault合约 0x489ee077994b6658eafa855c308275ead8097c4a   Token价格合约 0x2d68011bca022ed0e474264145f46cc4de96a002    相关交易操作交易Hash\n   操作名称 交易Hash     用户发起现货交易 0x0da7809c5f6372b5cc7342493fa405d0215d56ac47167b2682797df3ac4fca64    4.4 GMX质押和解除业务逻辑 4.4.1 GMX质押业务流程 GMX质押流程\n 用户向RewardRouter合约发起GMX质押。 RewardRouter合约调用sGMX RewardTracker合约，质押GMX并得到sGMX。 RewardRouter合约调用sbGMX RewardTracker合约，质押sGMX并得到sbGMX。 RewardRouter合约调用sbfGMX RewardTracker合约，质押sbGMX并得到sbfGMX。 用户最终得到sbfGMX。  4.4.2 GMX质押流程解读 质押业务由用户发起，质押核心业务逻辑在RewardRouter核心实现。质押具体逻辑主要由sGMX RewardTracker合约、sbGMX RewardTracker合约和sbfGMX RewardTracker合约来实现，它们的作用分别为\n sGMX RewardTracker合约是sGMX的ERC20合约，同时负责质押GMX并Mint sGMX。质押GMX的用户可以获取esGMX Token奖励。 sbGMX RewardTracker合约是sbGMX的ERC20合约，同时负责质押sGMX并Mint sbGMX。质押sGMX的用户可以获取bnGMX Token奖励。 sbfGMX RewardTracker合约是sbfGMX的ERC20合约，同时负责质押sbGMX并Mint sbfGMX。质押sbGMX的用户可以获取平台手续费，以WETH结算。 这样做的好处是RewardTracker合约即作为ERC20合约，又负责了质押业务，节省了合约gas成本。  esGMX是什么 esGMX等同与GMX，但是esGMX无法转账交易。用户可以把esGMX质押到gmxVestor合约，一年时间内esGMX就会在一年时间内线性地转换为GMX。\nbnGMX是什么 bnGMX会在restake进行二次质押，并且提升用户的APR。但是在unstake的时候，就会burn掉。\n相关合约地址\n   合约名称 合约地址     RewardRouter合约 0xa906f338cb21815cbc4bc87ace9e68c87ef8d8f1   sGMX RewardTracker合约 0x908c4d94d34924765f1edc22a1dd098397c59dd4   sbGMX RewardTracker合约 0x4d268a7d4c16ceb5a606c173bd974984343fea13   sbfGMX RewardTracker合约 0xd2d1162512f927a7e282ef43a362659e4f2a728f    相关交易操作交易Hash\n   操作名称 交易Hash     GMX质押 0xf885f7691effca2b0ba23423fa38941d3c2341598c6de208f025375e91d3c4e1    4.4.3 GMX解除质押业务流程 GMX解除质押流程\n 用户向RewardRouter合约发起GMX解除质押 RewardRouter合约调用sbfGMX RewardTracker合约，解除质押sbfGMX并得到sbGMX RewardRouter合约调用sbGMX RewardTracker合约，解除质押sbGMX并得到sGMX RewardRouter合约调用sGMX RewardTracker合约，解除质押sGMX并得到GMX 用户最终得到GMX  4.4.4 GMX解除质押流程解读 GMX解除质押业务流程就是质押流程的逆向操作，输入是sbfGMX，最终得到GMX。\n相关合约地址\n   合约名称 合约地址     RewardRouter合约 0xa906f338cb21815cbc4bc87ace9e68c87ef8d8f1   sGMX RewardTracker合约 0x908c4d94d34924765f1edc22a1dd098397c59dd4   sbGMX RewardTracker合约 0x4d268a7d4c16ceb5a606c173bd974984343fea13   sbfGMX RewardTracker合约 0xd2d1162512f927a7e282ef43a362659e4f2a728f    相关交易操作交易Hash\n   操作名称 交易Hash     GMX解除质押 0x1dc5efbc0ddfe09c3596407d1974647b787f77794a415e81df11ff21e8d683c3    4.5 GLP质押和解除业务逻辑 4.5.1 GLP质押业务流程 GLP质押流程\n 用户调用RewardRouter合约，发起GLP Mint和质押流程。 RewardRouter合约调用GlpManager合约，发起GLP Mint。 GlpManager合约调用Vault合约，消耗eth并mint 相应数量的USDg。 GlpManager合约调用GLP合约，消耗USDg并Mint GLP。 RewardRouter合约调用fGLP RewardTracker合约，质押GLP并得到fGLP。 RewardRouter合约调用fsGLP RewardTracker合约，质押fGLP并得到fsGLP。 最终用户得到fsGLP。  4.5.2 GLP质押流程解读 GLP的Mint和质押流程需要先通过GlpManager合约，把输入的eth兑换成USDg，1 USDg = 1 USD。再用USDg来兑换GLP。完成GLP兑换后再通过fGLP RewardTracker合约和fsGLP RewardTracker合约的循环质押，最终得到fsGLP。\n fGLP RewardTracker合约是fGLP的ERC20合约，同时负责质押GLP并Mint fGLP。质押GLP可以获得平台手续费，以WETH结算。 fsGLP RewardTracker合约是fsGLP的ERC20合约，同时负责质押fGLP并Mint fsGLP。质押fGLP可以获得esGMX Token奖励。  相关合约地址\n   合约名称 合约地址     RewardRouter合约 0xa906f338cb21815cbc4bc87ace9e68c87ef8d8f1   GlpManager合约 0x3963ffc9dff443c2a94f21b129d429891e32ec18   Vault合约 0x489ee077994b6658eafa855c308275ead8097c4a   GLP合约 0x4277f8f2c384827b5273592ff7cebd9f2c1ac258   fGLP RewardTracker合约 0x4e971a87900b931ff39d1aad67697f49835400b6   fsGLP RewardTracker合约 0x1addd80e6039594ee970e5872d247bf0414c8903    相关交易操作交易Hash\n   操作名称 交易Hash     GLP质押 0x348cffb309afeafe3fa252c355e6f27251ab40bb9dfa48b0b0ee8c40cf95d9e1    4.5.3 GLP解除质押业务流程 GLP解除质押流程\n 用户调用RewardRouter合约，发起GLP解除质押和burn流程。 RewardRouter合约调用fsGLP RewardTracker合约，burn fsGLP并得到fGLP。 RewardRouter合约调用fGLP RewardTracker合约，burn fGLP并得到GLP。 RewardRouter合约调用GlpManager合约，发起GLP burn。 GlpManager合约调用GLP合约，burn GLP并得到USDg。 GlpManager合约调用Vault合约，burn USDG并得到eth。 最终用户得到ETH。  4.5.4 GLP解除质押流程解读 GLP解除质押就是质押流程的逆向操作，输入是fsGLP，最终得到ETH。\n相关合约地址\n   合约名称 合约地址     RewardRouter合约 0xa906f338cb21815cbc4bc87ace9e68c87ef8d8f1   GlpManager合约 0x3963ffc9dff443c2a94f21b129d429891e32ec18   Vault合约 0x489ee077994b6658eafa855c308275ead8097c4a   GLP合约 0x4277f8f2c384827b5273592ff7cebd9f2c1ac258   fGLP RewardTracker合约 0x4e971a87900b931ff39d1aad67697f49835400b6   fsGLP RewardTracker合约 0x1addd80e6039594ee970e5872d247bf0414c8903    相关交易操作交易Hash\n   操作名称 交易Hash     GLP解除质押 0x79b20a42a9ed410772fea136b0f45bf1f35ea77a2726aef170c1ba9612109888    4.6 GMX领取质押收益业务逻辑 4.6.1 GMX领取质押收益业务流程 GMX领取收益流程\n 用户调用RewardRouter合约发起领取收益流程。 RewardRouter合约调用gmxVester合约领取GMX收益。 RewardRouter合约调用glpVester合约领取GMX收益。 RewardRouter合约调用sGMX RewardTracker合约领取esGMX收益。 RewardRouter合约调用fsGLP RewardTracker合约领取esGMX收益。 RewardRouter合约调用sbGMX RewardTracker合约领取bnGMX收益。 RewardRouter合约调用sbfGMX RewardTracker合约领取平台手续费，以WETH结算。 RewardRouter合约调用fGLP RewardTracker合约领取平台手续费，以WETH结算。 RewardRouter合约收到的GMX、esGMX和WETH发送给用户。  4.6.2 GMX领取质押收益流程解读 领取质押收益主要由用户发起，RewardRouter合约来调用其它收益合约来领取收益。\nRewardTracker合约的收益计算公式 可领取收益 = 用户质押数量 * 质押时长 * 单位质押单位时间的收益率 其中，单位质押单位时间的收益率由管理员来设置。\ngmxVester合约和glpVester合约是什么 gmxVester合约和glpVester合约是用来转换esGMX到GMX的合约。收益计算公式为 可领取收益 = esGMX质押数量 * 质押时长 / vestingDuration 其中，vestingDuration由管理员设置，目前设置为1年时间。\n相关合约地址\n   合约名称 合约地址     RewardRouter合约 0xa906f338cb21815cbc4bc87ace9e68c87ef8d8f1   gmxVester合约 0x199070ddfd1cfb69173aa2f7e20906f26b363004   glpVester合约 0xa75287d2f8b217273e7fcd7e86ef07d33972042e   fGLP RewardTracker合约 0x4e971a87900b931ff39d1aad67697f49835400b6   fsGLP RewardTracker合约 0x1addd80e6039594ee970e5872d247bf0414c8903   sGMX RewardTracker合约 0x908c4d94d34924765f1edc22a1dd098397c59dd4   sbGMX RewardTracker合约 0x4d268a7d4c16ceb5a606c173bd974984343fea13   sbfGMX RewardTracker合约 0xd2d1162512f927a7e282ef43a362659e4f2a728f    相关交易操作交易Hash\n   操作名称 交易Hash     领取质押收益 0x2731c50c5b63e80779aaa97b14a1d25cdf1f4ecc414204d583238fb38c076096    4.7 GMX平台手续费归集并分配收入业务逻辑 4.7.1 GMX平台手续费归集并分配收入业务流程 业务流程\n 由平台管理员统一从Vault合约中领取平台手续费。 Vault合约把手续费都转移到平台手续费收益管理员。 平台手续费收益管理员调用Router合约把手续费全都转换成WETH。  Router合约会调用Vault合约进行token swap。   平台手续费收益管理员最后把手续费都转移到RewardDistributor合约。 GMX质押用户领取手续费的时候，sbfGMX RewardTracker合约会从sbfGMX RewardDistributor合约获取手续费收入。 GLP质押用户领取手续费的时候，fGLP RewardTracker合约会从fGLP RewardDistributor合约获取手续费收入。  4.7.2 GMX平台手续费归集并分配收入业务解读 从流程图中可以看出，目前手续费分配的逻辑还是比较中心化的，需要平台管理员EOA账户和平台手续费收益管理员EOA账户来控制。\n 平台管理员EOA账户主要负责提取手续费到平台手续费收益管理员EOA账户。 平台手续费收益管理员EOA账户主要负责把收到的手续费都换成WETH，并把WETH都转移到RewardDistributor合约。  相关合约地址\n   合约名称 合约地址     Timelock合约 0xe7e740fa40ca16b15b621b49de8e9f0d69cf4858   Vault合约 0x489ee077994b6658eafa855c308275ead8097c4a   Router合约 0xabbc5f99639c9b6bcb58544ddf04efa6802f4064   sbfGMX RewardDistributor合约 0x1de098faf30bd74f22753c28db17a2560d4f5554   fGLP RewardDistributor合约 0x5c04a12eb54a093c396f61355c6da0b15890150d    相关交易操作交易Hash\n   操作名称 交易Hash     平台管理员提取手续费收益 0x8c0c1ceae993b037d003a195a72147a702f772986de3b4076cf614edaf6834d0   手续费管理员执行Token Swap 0x2612bce63d085248fee6193b0ca3ba189d353bc7d3f5492017c7a6c7d933cbfd   手续费管理员执行Token Swap 0x4b1a039541b367d3fe38db73d491d58b9d9dd5baf7e34cd9bdd5286725634536   手续费管理员执行Token Swap 0x8c46063bde7e5f415e0c0c72974c22ca28814f284f268f4565a071734d13bc8b   手续费管理员执行Token Swap 0x0ea7999ad2cb34bbd88e88be66bb5f7758b4f33283d1d20bc82f7e4b507afdf3   手续费管理员执行Token Swap 0x40cfbc735a065d63f9058cbde762dc1ca7fe7e39308b7b216e285d62a246c206   手续费管理员执行Token Swap 0x0d39b2273b70f677543a6f204810dd3e16abc0adb09804a721b4502b68b2c8b2   手续费管理员把WETH转移到sbfGMX RewardDistributor合约 0xe77d0ef63db5a776b976dc13f46d5942b7a11ccad953e20f3c7b7ae88f888679   手续费管理员把WETH转移到fGLP RewardDistributor合约 0x71e030541f1e10cd866ab15fa7eb3c0645ddeccce5c782baa7eb05f8d2490613    5 总结 总体来看，除了平台手续费分配这块还比较中心化，其它部分都是由智能合约自动完成。因此，可以说整个项目还是比较去中心化。随着中心交易所FTX暴雷，未来使用去中心化交易所可以说是大势所趋，去中心化合约交易所更是兵家必争之地。GMX作为去中心合约交易的龙头，它的优势也是非常明显：\n 去中心化。GMX是一个去中心化的永续合约交易平台，所有资产由智能合约保管，智能合约开源，所有运营数据也是公开透明的。 全额保证金。GMX上面的所有杠杆订单都是有全额保证金的，保障用户的收益能够钢性对付，很多中心化交易所都无法做到全额保证金。 市场报价去中心化。系统报价主要由ChainLink和报价机器人组成，报价公开透明，有效避免了恶意插针等扰乱市场的行为。 它的劣势也非常明显： 币种太少。包括4种主流代币、4种稳定币，不能满足大部分用户的需求。 无法做到Permissionless。由于GMX的架构设计，无法像Uniswap那样自由添加代币，它只能预先设定好支持哪些代币，无法自由扩展代币种类。 但不可否认的是，GMX所在的赛道发展潜力巨大，未来一定会诞生超级巨头。虽然GMX目前是去中心化永续合约交易所的龙头，但是还需要升级改造，解决目前平台目前的问题，让用户能像使用中心化永续合约交易所一样去使用去中心化的永续合约交易所。  ","permalink":"https://zhongxuqi.github.io/web3/2023-02-27/","summary":"0 GMX项目发展史 在2020年10月，xvi10启动了 xvix-contracts 项目，并部署到了Ethereum Mainnet。 在2021年3月，xvi10把 xvix-contracts 升级为 gambit-contracts ，并部署到了BSC。 在2021年9月，xvi10基于 gambit-contracts 启动GMX项目，并部署到了Arbitrum One。 在启动一周后，GMX完成了第一次升级，在eth、wbtc和usdc的基础上，添加了link、uni和usdt。 在启动三个月后，GMX，完成了第二次升级，部署到了Avalanche链上。\n1 GMX的产品设计目标 GMX的产品设计目标是打造一个去中心化的永续合约和现货交易平台。不需要任何注册、KYC和地域限制等限制，用户即可方便地用它进行链上资产交易和合约交易。\n2 GMX的核心卖点  去中心化。GMX是一个去中心化的永续合约交易平台，所有资产由智能合约保管，智能合约开源，所有运营数据也是公开透明的。 全额保证金。GMX上面的所有杠杆订单都是有全额保证金的，保障用户的收益能够钢性对付，很多中心化交易所都无法做到全额保证金。 无需许可Permissionless。所有人都可以公平得参与平台做市，并且根据GMX和GLP持有量平等地分到平台的盈利。 市场报价去中心化。系统报价主要由ChainLink和报价机器人组成，报价公开透明，有效避免了恶意插针等扰乱市场的行为。  3 GMX的系统整体设计 3.1 GMX系统架构图 其中，Vault合约是整个GMX的核心，负责管理GMX平台的全部资产。\n3.2 系统核心数据模型 { \t\u0026#34;id\u0026#34;: keccak256(_account, _collateralToken, _indexToken, _isLong), // 仓位ID \t\u0026#34;size\u0026#34;: uint256, // Position大小 \t\u0026#34;collateral\u0026#34;: uint256, // 抵押品价格 USD \t\u0026#34;averagePrice\u0026#34;: uint256, // 平均持仓价格 USD \t\u0026#34;entryFundingRate\u0026#34;: uint256, // 入场资金费率 \t\u0026#34;reserveAmount\u0026#34;: uint256, // 抵押品token储备数量 \t\u0026#34;realisedPnl\u0026#34;: int256, // 已兑付盈亏 \t\u0026#34;lastIncreasedTime\u0026#34;: uint256, // 最后加仓时间 } 盈亏USD价值计算：","title":"深度解读GMX：去中心化永续合约交易所"},{"content":"随着Damus最近的大火，其内置的比特币闪电网络Lightning Network打赏功能也走进了大众的视野。闪电网络的比特币容量也随之猛增到5400枚，创下历史新高。那么下面我们就重点来介绍一下闪电网络的作用和工作原理。\n什么是闪电网络 闪电网络是建立在Bitcoin链上的2层网络，即Bitcoin的L2。它的主要作用是解决比特币扩展性和交易手续费高的问题。 可以说闪电网络的TPS远超市面上所有区块链技术，如下表所示\n    Lightning Network Solana Visa Paypal Ethereum Bitcoin     TPS 40,000,000 65,000 24,000 193 15 7    闪电网络的TPS是目前区块链所有扩容方案中最高的，满足了目前所有的支付场景需求。\n闪电网络的工作原理 闪电网络的基本流程就是在用户之间点对点地建立一些支付通道，建立好通道的用户可以方便地进行链下建议。然后随着越来越多的用户之间建立了支付通道，就形成了一张支付通道网络，就此闪电网络就形成了，只要在网络中的用户之间都可以进行相互链下交易。\n建立支付通道 支付通道是点对点的，即两个用户之间。打个比方，用户A和用户B要建立一个10btc的支付通道，他们分别都支付了5btc（实际A和B的通道建立金额可以任意），具体如下图所示 上图的流程步骤为：\n A和B分别用自己的UTXO-A和UTXO-B作为输入，共同签名上链并输出了UTXO-AB A生成链下交易TX-A1，并让B对TX-A1签名。 B生成链下交易TX-B1，并让A对TX-B1签名。  其中UTXO-AB就是A和B之间建立的支付通道，TX-A1和TX-B1不需要广播到链上，如果TX-A1和TX-B1被广播到链上就代表支付通道被关闭了。 TX-A1由A持有，TX-B1由B持有，他们都可以随时关闭通道取出自己的钱。 如果A广播了TX-A1，那么就会生成UTXO-A1-A和UTXO-A1-B。 UTXO-A1-A的使用需要满足以下条件之一即可：\n 需要等x个区块才能被A密钥使用 可以用B密钥和A1密钥共同签名使用，A1密钥由A保管  UTXO-A1-B的使用需要满足以下条件之一即可：\n 用B密钥签名即可使用  同理如果B广播了TX-B1，那么就会生成UTXO-B1-A和UTXO-B1-B。 UTXO-B1-A的使用需要满足以下条件之一即可：\n 用A密钥签名即可使用  UTXO-B1-B的使用需要满足以下条件之一即可：\n 需要等x个区块才能被B密钥使用 可以用A密钥和B1密钥共同签名使用，B1密钥由B保管  用户之间点对点转账 用户A要向用户B转1个BTC，具体流程图如下 具体流程为\n 用户A用A2密值构建交易TX-A2，并提交给用户B签名，用户B把TX-A2的签名传给用户A 用户A把A1密值传给B 用户B用B2密值构建交易TX-B2，并提交给用户A签名，用户A把TX-B2的签名传给用户B 用户B把B2密值传给A 完成以上4步后才算转账完成  如何防止用户作恶 假设用户A想作恶，转账给B 1个BTC后，故意把TX-A1广播出去，企图从支付通道中取回5BTC。 具体流程如下\n 完成转账1BTC后，A把TX-A1广播到链上。 UTXO-AB被使用，生成新的UTXO-A1-A和UTXO-A1-B。 这是闪电网络瞭望塔发现了支付通道被关闭，并通知到用户B 用户B收到通知后用B密钥签名取回UTXO-A1-B的5BTC。 用户A要等待x个区块后才能取出UTXO-A1-A的钱，导致目前还无法取出。 用户B用B密钥和得到的A1密值从UTXO-A1-A中取出5BTC，用户A损失了全部的BTC。 由此可知，任何作恶用户的结局就是损失全部的资产。  闪电网络跨用户转账 任何用户之间只要在相同的闪电网络中，都可以方便地进行支付。 假设用户A想和用户C交易，但是他们之间没有直接支付通道，但是用户B和用户C之间由支付通道。那么用户A可以通过用户B间接与用户C转账BTC。具体流程如下 走完以上四步流程后，就完成了一次闪电网络交易。 随着越来越多的用户组成了一个更大的闪电网络，那么闪电网络里面的用户之间都可以方便地进行交易。 闪电网络目前使用的痛点  自主托管和备份通道状态 可能存储大量撤销密钥 离线后上线遭受意外惩罚  没有备份到最新状态   再平衡通道余额  商家-消费者    总结 目前闪电网络的通道容量已经突破5400BTC，创下历史新高。毫无疑问，闪电网络是比特币生态目前最有前景的方向，它解决了比特币网络的扩展性和交易手续费问题，使得比特币支付成为可能，是一个非常值得区块链用户和开发者密切关注的发展方向。\n","permalink":"https://zhongxuqi.github.io/web3/2023-02-07/","summary":"随着Damus最近的大火，其内置的比特币闪电网络Lightning Network打赏功能也走进了大众的视野。闪电网络的比特币容量也随之猛增到5400枚，创下历史新高。那么下面我们就重点来介绍一下闪电网络的作用和工作原理。\n什么是闪电网络 闪电网络是建立在Bitcoin链上的2层网络，即Bitcoin的L2。它的主要作用是解决比特币扩展性和交易手续费高的问题。 可以说闪电网络的TPS远超市面上所有区块链技术，如下表所示\n    Lightning Network Solana Visa Paypal Ethereum Bitcoin     TPS 40,000,000 65,000 24,000 193 15 7    闪电网络的TPS是目前区块链所有扩容方案中最高的，满足了目前所有的支付场景需求。\n闪电网络的工作原理 闪电网络的基本流程就是在用户之间点对点地建立一些支付通道，建立好通道的用户可以方便地进行链下建议。然后随着越来越多的用户之间建立了支付通道，就形成了一张支付通道网络，就此闪电网络就形成了，只要在网络中的用户之间都可以进行相互链下交易。\n建立支付通道 支付通道是点对点的，即两个用户之间。打个比方，用户A和用户B要建立一个10btc的支付通道，他们分别都支付了5btc（实际A和B的通道建立金额可以任意），具体如下图所示 上图的流程步骤为：\n A和B分别用自己的UTXO-A和UTXO-B作为输入，共同签名上链并输出了UTXO-AB A生成链下交易TX-A1，并让B对TX-A1签名。 B生成链下交易TX-B1，并让A对TX-B1签名。  其中UTXO-AB就是A和B之间建立的支付通道，TX-A1和TX-B1不需要广播到链上，如果TX-A1和TX-B1被广播到链上就代表支付通道被关闭了。 TX-A1由A持有，TX-B1由B持有，他们都可以随时关闭通道取出自己的钱。 如果A广播了TX-A1，那么就会生成UTXO-A1-A和UTXO-A1-B。 UTXO-A1-A的使用需要满足以下条件之一即可：\n 需要等x个区块才能被A密钥使用 可以用B密钥和A1密钥共同签名使用，A1密钥由A保管  UTXO-A1-B的使用需要满足以下条件之一即可：\n 用B密钥签名即可使用  同理如果B广播了TX-B1，那么就会生成UTXO-B1-A和UTXO-B1-B。 UTXO-B1-A的使用需要满足以下条件之一即可：\n 用A密钥签名即可使用  UTXO-B1-B的使用需要满足以下条件之一即可：\n 需要等x个区块才能被B密钥使用 可以用A密钥和B1密钥共同签名使用，B1密钥由B保管  用户之间点对点转账 用户A要向用户B转1个BTC，具体流程图如下 具体流程为\n 用户A用A2密值构建交易TX-A2，并提交给用户B签名，用户B把TX-A2的签名传给用户A 用户A把A1密值传给B 用户B用B2密值构建交易TX-B2，并提交给用户A签名，用户A把TX-B2的签名传给用户B 用户B把B2密值传给A 完成以上4步后才算转账完成  如何防止用户作恶 假设用户A想作恶，转账给B 1个BTC后，故意把TX-A1广播出去，企图从支付通道中取回5BTC。 具体流程如下","title":"解读闪电网络Lightning Network原理"},{"content":"近期damus社交软件大火，作为web3赛道率先上线app store的应用，很快引起了圈内圈外人士的关注。那么不少会有一个疑问，同样作为社交软件，web3赛道的damus相比于web2赛道的twitter和微博有什么优势，用户为什么要迁移到web3社交产品呢？ 首先，看下damus官方给出的web2社交的一些关键问题：\n web2社交有广告，比如twitter上经常会看到一些广告，非常影响用户体验。 web2社交会使用一些推荐技术让用户上瘾，比如twitter、tiktok都有自己的推荐算法，推荐算法会根据用户喜好不断推荐一些类似的内容，吸引用户留存。 web2产品能封禁用户，比如特朗普的twitter账户就曾被twitter封禁。 web2产品能对用户限流，导致用户的推文无法被其它用户看到。 web2产品有很多垃圾信息。  上述问题导致web2产品无法实现真正的言论自由，根本原因在于web2产品是有专门中心化的公司和机构运营和维护，而且永远无法被替换。这些公司和机构为了盈利的目的，会破坏社交软件的言论自由。 为了实现真正的言论自由，web3就是一个很好的技术发展方向。web3的任何产品都不会由中心化的机构和公司来维护和运营，全靠社区和用户自主来维护，而且产品的代码也是开源的，任何人都可以下载阅读并参与开发。 那么Damus是如何做到的呢？那就不得不说一下它背后的去中心化社交协议Nostr了。打个比方，如果说Damus是一个大楼，那么nostr就是这个大楼的地基。\n技术原理 Nostr是什么 Nostr是一个p2p的社交网络协议，基于密码学的公钥私钥和签名技术，并且不需要依赖任何的中心化服务器。\nNostr是如何工作的 Nostr网络由client和relay两个角色组成，用户运行client（比如手机上运行damus客户端），任何个人或者机构都可以运行relay。\n发送推文流程  第一步，用户使用客服端需要先生成公钥私钥，私钥相当于用户身份，不能对外公开。 第二步，用户在客户端提交推文内容，client会用私钥对推文内容进行签名， 第三步，client会把推文、公钥和签名发送到配置好的relay，relay会用公钥校验签名正确性。 推文内容格式为  {  \u0026#34;id\u0026#34;: \u0026#34;\u0026lt;消息ID\u0026gt;\u0026#34;,  \u0026#34;pubkey\u0026#34;: \u0026#34;\u0026lt;用户公钥\u0026gt;\u0026#34;,  \u0026#34;created_at\u0026#34;: \u0026#34;\u0026lt;创建时间\u0026gt;\u0026#34;,  \u0026#34;kind\u0026#34;: \u0026#34;\u0026lt;消息类型\u0026gt;\u0026#34;,  \u0026#34;tags\u0026#34;: [ // \u0026lt;用于订阅规则过滤\u0026gt;  [\u0026#34;e\u0026#34;, \u0026#34;\u0026lt;其它推文ID\u0026gt;\u0026#34;, \u0026#34;\u0026lt;推荐relay地址\u0026gt;\u0026#34;],  [\u0026#34;p\u0026#34;, \u0026#34;\u0026lt;公钥\u0026gt;\u0026#34;, \u0026#34;\u0026lt;推荐relay地址\u0026gt;\u0026#34;]  ... // other kinds of tags may be included later  ],  \u0026#34;content\u0026#34;: \u0026#34;\u0026lt;推文内容\u0026gt;\u0026#34;,  \u0026#34;sig\u0026#34;: \u0026#34;\u0026lt;私钥签名\u0026gt;\u0026#34; } 其中，id=sha256(JSON.stringify[0,pubkey,created_at,kind,tags,content])，sig=seckey.sign(id)\n接收推文流程  第一步，用户通过client发送推文订阅消息到relay。订阅消息格式为  [\u0026#34;REQ\u0026#34;, \u0026#34;\u0026lt;subscription_id\u0026gt;\u0026#34;, {  \u0026#34;ids\u0026#34;: \u0026#34;\u0026lt;消息ID json array\u0026gt;\u0026#34;,  \u0026#34;authors\u0026#34;: \u0026#34;\u0026lt;被订阅用户的pubkey json array\u0026gt;\u0026#34;,  \u0026#34;kinds\u0026#34;: \u0026#34;\u0026lt;消息类型 json array\u0026gt;\u0026#34;,  \u0026#34;#e\u0026#34;: \u0026#34;\u0026lt;\u0026#39;e\u0026#39; tag json array\u0026gt;\u0026#34;,  \u0026#34;#p\u0026#34;: \u0026#34;\u0026lt;\u0026#39;p\u0026#39; tag json array\u0026gt;\u0026#34;,  \u0026#34;since\u0026#34;: \u0026#34;\u0026lt;订阅开始时间\u0026gt;\u0026#34;,  \u0026#34;until\u0026#34;: \u0026#34;\u0026lt;订阅结束时间\u0026gt;\u0026#34;,  \u0026#34;limit\u0026#34;: \u0026#34;\u0026lt;初次订阅返回的最大历史推文数量\u0026gt;\u0026#34; }, ...] 其中，subscription_id为客户端随机生成的uuid字符串 2. 第二步，relay发送推文消息到client。消息格式为\n[\u0026#34;EVENT\u0026#34;, \u0026#34;\u0026lt;subscription_id\u0026gt;\u0026#34;, {  \u0026#34;id\u0026#34;: \u0026#34;\u0026lt;消息ID\u0026gt;\u0026#34;,  \u0026#34;pubkey\u0026#34;: \u0026#34;\u0026lt;用户公钥\u0026gt;\u0026#34;,  \u0026#34;created_at\u0026#34;: \u0026#34;\u0026lt;创建时间\u0026gt;\u0026#34;,  \u0026#34;kind\u0026#34;: \u0026#34;\u0026lt;消息类型\u0026gt;\u0026#34;,  \u0026#34;tags\u0026#34;: [ // \u0026lt;用于订阅规则过滤\u0026gt;  [\u0026#34;e\u0026#34;, \u0026#34;\u0026lt;其它推文ID\u0026gt;\u0026#34;, \u0026#34;\u0026lt;推荐relay地址\u0026gt;\u0026#34;],  [\u0026#34;p\u0026#34;, \u0026#34;\u0026lt;公钥\u0026gt;\u0026#34;, \u0026#34;\u0026lt;推荐relay地址\u0026gt;\u0026#34;]  ... // other kinds of tags may be included later  ],  \u0026#34;content\u0026#34;: \u0026#34;\u0026lt;推文内容\u0026gt;\u0026#34;,  \u0026#34;sig\u0026#34;: \u0026#34;\u0026lt;私钥签名\u0026gt;\u0026#34; }] 取消推文流程 用户通过客户端发送关闭订阅消息\n[\u0026#34;CLOSE\u0026#34;, \u0026#34;\u0026lt;subscription_id\u0026gt;\u0026#34;] Damus如何实现推文评论 damus基于tags字段来实现推文评论功能，具体格式如下：\n{  ...  \u0026#34;tags\u0026#34;: [  [\u0026#34;e\u0026#34;, \u0026#34;\u0026lt;推文ID\u0026gt;\u0026#34;, \u0026#34;\u0026lt;推荐relay地址\u0026gt;\u0026#34;, \u0026#34;root\u0026#34;], // 评论链的根推文ID，必有  [\u0026#34;e\u0026#34;, \u0026#34;\u0026lt;推文ID\u0026gt;\u0026#34;, \u0026#34;\u0026lt;推荐relay地址\u0026gt;\u0026#34;, \u0026#34;mention\u0026#34;], // 相关推文ID，可选  [\u0026#34;e\u0026#34;, \u0026#34;\u0026lt;推文ID\u0026gt;\u0026#34;, \u0026#34;\u0026lt;推荐relay地址\u0026gt;\u0026#34;, \u0026#34;reply\u0026#34;], // 被评论推文ID，可选。如果没有就是root推文ID  ...  ],  ... } Damus是如何管理用户信息 client会把用户信息发送到relay，格式如下\n{  \u0026#34;kind\u0026#34;: 0,  \u0026#34;name\u0026#34;: \u0026#34;用户名\u0026#34;,  \u0026#34;about\u0026#34;: \u0026#34;\u0026#34;,  \u0026#34;picture\u0026#34;: \u0026#34;\u0026#34;,  ... // other fields } 用户可以通过发送订阅消息来获取自己的用户信息，格式如下\n[\u0026#34;REQ\u0026#34;, \u0026#34;\u0026lt;subscription_id\u0026gt;\u0026#34;, {  \u0026#34;authors\u0026#34;: \u0026#34;\u0026lt;用户的公钥\u0026gt;\u0026#34;,  \u0026#34;kinds\u0026#34;: [0] }] Damus的follower和following原理 following用户本地会维护一份contact列表，格式如下\n{  \u0026#34;kind\u0026#34;: 3,  \u0026#34;tags\u0026#34;: [  [\u0026#34;p\u0026#34;, \u0026#34;91cf9..4e5ca\u0026#34;, \u0026#34;wss://alicerelay.com/\u0026#34;, \u0026#34;alice\u0026#34;], // 订阅用户1  [\u0026#34;p\u0026#34;, \u0026#34;14aeb..8dad4\u0026#34;, \u0026#34;wss://bobrelay.com/nostr\u0026#34;, \u0026#34;bob\u0026#34;], // 订阅用户2  [\u0026#34;p\u0026#34;, \u0026#34;612ae..e610f\u0026#34;, \u0026#34;ws://carolrelay.com/ws\u0026#34;, \u0026#34;carol\u0026#34;] // 订阅用户3  ],  \u0026#34;content\u0026#34;: \u0026#34;\u0026#34;,  ...other fields } 这些都是订阅的用户pubkey。但用户定阅新的用户或者取消已由的用户订阅的时候，会往relay发送新的contact列表，例如删除carol，订阅新的用户xxx\n{  \u0026#34;kind\u0026#34;: 3,  \u0026#34;tags\u0026#34;: [  [\u0026#34;p\u0026#34;, \u0026#34;91cf9..4e5ca\u0026#34;, \u0026#34;wss://alicerelay.com/\u0026#34;, \u0026#34;alice\u0026#34;], // 订阅用户1  [\u0026#34;p\u0026#34;, \u0026#34;14aeb..8dad4\u0026#34;, \u0026#34;wss://bobrelay.com/nostr\u0026#34;, \u0026#34;bob\u0026#34;], // 订阅用户1  [\u0026#34;p\u0026#34;, \u0026#34;xxx\u0026#34;, \u0026#34;ws://carolrelay.com/ws\u0026#34;, \u0026#34;xxx\u0026#34;] // 订阅用户4  ],  \u0026#34;content\u0026#34;: \u0026#34;\u0026#34;,  ...other fields } 那么如何计算following就很简单，如果是在旧设备登录，只需要获取本地的订阅用户列表即可；如果是在新设备登录，就需要从relay中获取contact列表，那么就需要发送订阅消息，例如\n[\u0026#34;REQ\u0026#34;, \u0026#34;\u0026lt;subscription_id\u0026gt;\u0026#34;, {  \u0026#34;authors\u0026#34;: \u0026#34;\u0026lt;用户的公钥\u0026gt;\u0026#34;,  \u0026#34;kinds\u0026#34;: [3] }] 如何计算follower数量，也需要往relay发送订阅消息，例如\n[\u0026#34;REQ\u0026#34;, \u0026#34;\u0026lt;subscription_id\u0026gt;\u0026#34;, {  \u0026#34;kinds\u0026#34;: \u0026#34;3\u0026#34;,  \u0026#34;pubkeys\u0026#34;: \u0026#34;\u0026lt;被订阅用户的pubkey json array\u0026gt;\u0026#34; }] 根据relay返回的消息条数就可以计算\nNostr目前存在的一些缺陷和问题  无法发送图片等多媒体资源。因为nostr只负责发送文本消息，因此结合外部系统才能支持多媒体数据的上传。 relay提供商缺少激励机制。目前relay服务提供商属于完成免费提供服务，长期看并不稳定可靠。 无法发送私信。由于推文内容目前都是对外公开的，还无法支持用户和用户之间点对点的私信。 seckey作为用户的唯一身份验证，如果不小心泄露，那么用户账号就会永久丢失，无法重新恢复。  总结 总体上看，Damus是一款优缺点很明显的社交软件。它的去中心化特点可以最大化实现言论自由，同时也正是去中心导致用户体验上做了很多妥协。以Damus目前的产品，显然无法吸引绝大多数web2社交上的用户。这种新赛道的产品还是非常值得我们去持续关注的，等它解决好自身的问题后，可能会在未来的某个时间突然爆发。\n","permalink":"https://zhongxuqi.github.io/web3/2023-02-04/","summary":"近期damus社交软件大火，作为web3赛道率先上线app store的应用，很快引起了圈内圈外人士的关注。那么不少会有一个疑问，同样作为社交软件，web3赛道的damus相比于web2赛道的twitter和微博有什么优势，用户为什么要迁移到web3社交产品呢？ 首先，看下damus官方给出的web2社交的一些关键问题：\n web2社交有广告，比如twitter上经常会看到一些广告，非常影响用户体验。 web2社交会使用一些推荐技术让用户上瘾，比如twitter、tiktok都有自己的推荐算法，推荐算法会根据用户喜好不断推荐一些类似的内容，吸引用户留存。 web2产品能封禁用户，比如特朗普的twitter账户就曾被twitter封禁。 web2产品能对用户限流，导致用户的推文无法被其它用户看到。 web2产品有很多垃圾信息。  上述问题导致web2产品无法实现真正的言论自由，根本原因在于web2产品是有专门中心化的公司和机构运营和维护，而且永远无法被替换。这些公司和机构为了盈利的目的，会破坏社交软件的言论自由。 为了实现真正的言论自由，web3就是一个很好的技术发展方向。web3的任何产品都不会由中心化的机构和公司来维护和运营，全靠社区和用户自主来维护，而且产品的代码也是开源的，任何人都可以下载阅读并参与开发。 那么Damus是如何做到的呢？那就不得不说一下它背后的去中心化社交协议Nostr了。打个比方，如果说Damus是一个大楼，那么nostr就是这个大楼的地基。\n技术原理 Nostr是什么 Nostr是一个p2p的社交网络协议，基于密码学的公钥私钥和签名技术，并且不需要依赖任何的中心化服务器。\nNostr是如何工作的 Nostr网络由client和relay两个角色组成，用户运行client（比如手机上运行damus客户端），任何个人或者机构都可以运行relay。\n发送推文流程  第一步，用户使用客服端需要先生成公钥私钥，私钥相当于用户身份，不能对外公开。 第二步，用户在客户端提交推文内容，client会用私钥对推文内容进行签名， 第三步，client会把推文、公钥和签名发送到配置好的relay，relay会用公钥校验签名正确性。 推文内容格式为  {  \u0026#34;id\u0026#34;: \u0026#34;\u0026lt;消息ID\u0026gt;\u0026#34;,  \u0026#34;pubkey\u0026#34;: \u0026#34;\u0026lt;用户公钥\u0026gt;\u0026#34;,  \u0026#34;created_at\u0026#34;: \u0026#34;\u0026lt;创建时间\u0026gt;\u0026#34;,  \u0026#34;kind\u0026#34;: \u0026#34;\u0026lt;消息类型\u0026gt;\u0026#34;,  \u0026#34;tags\u0026#34;: [ // \u0026lt;用于订阅规则过滤\u0026gt;  [\u0026#34;e\u0026#34;, \u0026#34;\u0026lt;其它推文ID\u0026gt;\u0026#34;, \u0026#34;\u0026lt;推荐relay地址\u0026gt;\u0026#34;],  [\u0026#34;p\u0026#34;, \u0026#34;\u0026lt;公钥\u0026gt;\u0026#34;, \u0026#34;\u0026lt;推荐relay地址\u0026gt;\u0026#34;]  ... // other kinds of tags may be included later  ],  \u0026#34;content\u0026#34;: \u0026#34;\u0026lt;推文内容\u0026gt;\u0026#34;,  \u0026#34;sig\u0026#34;: \u0026#34;\u0026lt;私钥签名\u0026gt;\u0026#34; } 其中，id=sha256(JSON.","title":"解读Damus和去中心化社交协议Nostr"},{"content":"1. 安装Hardhat npm install --save-dev hardhat 2. 初始化Hardhat工程 npx hardhat 3. 安装官方contract库 npm install @openzeppelin/contracts 4. 完成ERC721 NFT智能合约代码 目录contracts/DrawNFT.sol\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.4;  import \u0026#34;@openzeppelin/contracts/token/ERC721/ERC721.sol\u0026#34;; import \u0026#34;@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\u0026#34;; import \u0026#34;@openzeppelin/contracts/access/Ownable.sol\u0026#34;; import \u0026#34;@openzeppelin/contracts/utils/Counters.sol\u0026#34;;  contract DrawNFT is ERC721, ERC721URIStorage, Ownable {  using Counters for Counters.Counter;   Counters.Counter private _tokenIdCounter;   constructor() ERC721(\u0026#34;DrawNFT\u0026#34;, \u0026#34;DNFT\u0026#34;) {}   function safeMint(address to, string memory uri) public onlyOwner {  uint256 tokenId = _tokenIdCounter.current();  _tokenIdCounter.increment();  _safeMint(to, tokenId);  _setTokenURI(tokenId, uri);  }   // The following functions are overrides required by Solidity.   function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {  super._burn(tokenId);  }   function tokenURI(uint256 tokenId)  public  view  override(ERC721, ERC721URIStorage)  returns (string memory)  {  return super.tokenURI(tokenId);  } } 5. 完成合约部署代码 目录scripts/deploy.ts\nimport { ethers } from \u0026#34;hardhat\u0026#34;;  async function main() {  // DrawNFT  const DrawNFT = await ethers.getContractFactory(\u0026#34;DrawNFT\u0026#34;);  const drawNFT = await DrawNFT.deploy();  await drawNFT.deployed();  console.log(`drawNFT deployed to ${drawNFT.address}`); }  // We recommend this pattern to be able to use async/await everywhere // and properly handle errors. main().catch((error) =\u0026gt; {  console.error(error);  process.exitCode = 1; }); 6. 启动本地私有链 npx hardhat node 7. 部署合约 npx hardhat run --network localhost scripts/deploy.ts 得到合约地址\ndrawNFT deployed to 0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512 8. 启动nodejs，并初始化环境 # node Welcome to Node.js v16.15.1. Type \u0026#34;.help\u0026#34; for more information. \u0026gt; const { ethers } = require(\u0026#34;ethers\u0026#34;); undefined \u0026gt; const provider = new ethers.providers.JsonRpcProvider(); undefined \u0026gt; account1 = new ethers.Wallet(\u0026#39;0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80\u0026#39;,provider) Wallet {  _isSigner: true,  _signingKey: [Function (anonymous)],  _mnemonic: [Function (anonymous)],  address: \u0026#39;0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\u0026#39;,  provider: JsonRpcProvider {  _isProvider: true,  _events: [],  _emitted: { block: -2 },  disableCcipRead: false,  formatter: Formatter { formats: [Object] },  anyNetwork: false,  _networkPromise: Promise {  [Object],  [Symbol(async_id_symbol)]: 47,  [Symbol(trigger_async_id_symbol)]: 5,  [Symbol(destroyed)]: [Object]  },  _maxInternalBlockNumber: -1024,  _lastBlockNumber: -2,  _maxFilterBlockRange: 10,  _pollingInterval: 4000,  _fastQueryDate: 0,  connection: { url: \u0026#39;http://localhost:8545\u0026#39; },  _nextId: 43,  _eventLoopCache: { detectNetwork: null, eth_chainId: null },  _network: { chainId: 31337, name: \u0026#39;unknown\u0026#39; }  } } 9. 初始化contract \u0026gt; abi = [{\u0026#34;inputs\u0026#34;:[],\u0026#34;stateMutability\u0026#34;:\u0026#34;nonpayable\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;constructor\u0026#34;},{\u0026#34;anonymous\u0026#34;:false,\u0026#34;inputs\u0026#34;:[{\u0026#34;indexed\u0026#34;:true,\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;owner\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;indexed\u0026#34;:true,\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;approved\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;indexed\u0026#34;:true,\u0026#34;internalType\u0026#34;:\u0026#34;uint256\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;tokenId\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;uint256\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;Approval\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;event\u0026#34;},{\u0026#34;anonymous\u0026#34;:false,\u0026#34;inputs\u0026#34;:[{\u0026#34;indexed\u0026#34;:true,\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;owner\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;indexed\u0026#34;:true,\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;operator\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;indexed\u0026#34;:false,\u0026#34;internalType\u0026#34;:\u0026#34;bool\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;approved\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;bool\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;ApprovalForAll\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;event\u0026#34;},{\u0026#34;anonymous\u0026#34;:false,\u0026#34;inputs\u0026#34;:[{\u0026#34;indexed\u0026#34;:true,\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;previousOwner\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;indexed\u0026#34;:true,\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;newOwner\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;OwnershipTransferred\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;event\u0026#34;},{\u0026#34;anonymous\u0026#34;:false,\u0026#34;inputs\u0026#34;:[{\u0026#34;indexed\u0026#34;:true,\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;from\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;indexed\u0026#34;:true,\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;to\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;indexed\u0026#34;:true,\u0026#34;internalType\u0026#34;:\u0026#34;uint256\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;tokenId\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;uint256\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;Transfer\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;event\u0026#34;},{\u0026#34;inputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;to\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;internalType\u0026#34;:\u0026#34;uint256\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;tokenId\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;uint256\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;approve\u0026#34;,\u0026#34;outputs\u0026#34;:[],\u0026#34;stateMutability\u0026#34;:\u0026#34;nonpayable\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;owner\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;balanceOf\u0026#34;,\u0026#34;outputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;uint256\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;uint256\u0026#34;}],\u0026#34;stateMutability\u0026#34;:\u0026#34;view\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;uint256\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;tokenId\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;uint256\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;getApproved\u0026#34;,\u0026#34;outputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;}],\u0026#34;stateMutability\u0026#34;:\u0026#34;view\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;owner\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;operator\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;isApprovedForAll\u0026#34;,\u0026#34;outputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;bool\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;bool\u0026#34;}],\u0026#34;stateMutability\u0026#34;:\u0026#34;view\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[],\u0026#34;name\u0026#34;:\u0026#34;name\u0026#34;,\u0026#34;outputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;string\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;string\u0026#34;}],\u0026#34;stateMutability\u0026#34;:\u0026#34;view\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[],\u0026#34;name\u0026#34;:\u0026#34;owner\u0026#34;,\u0026#34;outputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;}],\u0026#34;stateMutability\u0026#34;:\u0026#34;view\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;uint256\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;tokenId\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;uint256\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;ownerOf\u0026#34;,\u0026#34;outputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;}],\u0026#34;stateMutability\u0026#34;:\u0026#34;view\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[],\u0026#34;name\u0026#34;:\u0026#34;renounceOwnership\u0026#34;,\u0026#34;outputs\u0026#34;:[],\u0026#34;stateMutability\u0026#34;:\u0026#34;nonpayable\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;to\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;internalType\u0026#34;:\u0026#34;string\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;uri\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;string\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;safeMint\u0026#34;,\u0026#34;outputs\u0026#34;:[],\u0026#34;stateMutability\u0026#34;:\u0026#34;nonpayable\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;from\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;to\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;internalType\u0026#34;:\u0026#34;uint256\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;tokenId\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;uint256\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;safeTransferFrom\u0026#34;,\u0026#34;outputs\u0026#34;:[],\u0026#34;stateMutability\u0026#34;:\u0026#34;nonpayable\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;from\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;to\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;internalType\u0026#34;:\u0026#34;uint256\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;tokenId\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;uint256\u0026#34;},{\u0026#34;internalType\u0026#34;:\u0026#34;bytes\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;data\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;bytes\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;safeTransferFrom\u0026#34;,\u0026#34;outputs\u0026#34;:[],\u0026#34;stateMutability\u0026#34;:\u0026#34;nonpayable\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;operator\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;internalType\u0026#34;:\u0026#34;bool\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;approved\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;bool\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;setApprovalForAll\u0026#34;,\u0026#34;outputs\u0026#34;:[],\u0026#34;stateMutability\u0026#34;:\u0026#34;nonpayable\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;bytes4\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;interfaceId\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;bytes4\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;supportsInterface\u0026#34;,\u0026#34;outputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;bool\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;bool\u0026#34;}],\u0026#34;stateMutability\u0026#34;:\u0026#34;view\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[],\u0026#34;name\u0026#34;:\u0026#34;symbol\u0026#34;,\u0026#34;outputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;string\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;string\u0026#34;}],\u0026#34;stateMutability\u0026#34;:\u0026#34;view\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;uint256\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;tokenId\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;uint256\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;tokenURI\u0026#34;,\u0026#34;outputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;string\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;string\u0026#34;}],\u0026#34;stateMutability\u0026#34;:\u0026#34;view\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;from\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;to\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;internalType\u0026#34;:\u0026#34;uint256\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;tokenId\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;uint256\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;transferFrom\u0026#34;,\u0026#34;outputs\u0026#34;:[],\u0026#34;stateMutability\u0026#34;:\u0026#34;nonpayable\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;newOwner\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;transferOwnership\u0026#34;,\u0026#34;outputs\u0026#34;:[],\u0026#34;stateMutability\u0026#34;:\u0026#34;nonpayable\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;}] ... \u0026gt; contract = new ethers.Contract(\u0026#39;0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512\u0026#39;,abi,account1) ... 调用合约基本方法\n\u0026gt; await contract.name() \u0026#39;DrawNFT\u0026#39; \u0026gt; await contract.symbol() \u0026#39;DNFT\u0026#39; 10. mint出token \u0026gt; contractWithSigner = contract.connect(account1) ... \u0026gt; contractWithSigner.safeMint(await account1.getAddress(),\u0026#39;ipfs://Qmxxx\u0026#39;) {  type: 2,  chainId: 31337,  nonce: 2,  maxPriorityFeePerGas: BigNumber { _hex: \u0026#39;0x59682f00\u0026#39;, _isBigNumber: true },  maxFeePerGas: BigNumber { _hex: \u0026#39;0xb5f20e1e\u0026#39;, _isBigNumber: true },  gasPrice: null,  gasLimit: BigNumber { _hex: \u0026#39;0x01cd79\u0026#39;, _isBigNumber: true },  to: \u0026#39;0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512\u0026#39;,  value: BigNumber { _hex: \u0026#39;0x00\u0026#39;, _isBigNumber: true },  data: \u0026#39;0xd204c45e000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb922660000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000c697066733a2f2f516d7878780000000000000000000000000000000000000000\u0026#39;,  accessList: [],  hash: \u0026#39;0x2884d83034461908dbd3be73470d36af5aec159098a8d6d049027cb5acc2c61d\u0026#39;,  v: 0,  r: \u0026#39;0x825d7e0024a83a417f5ead21fc07044fb6e74253dea5b4de788a15c7344f1679\u0026#39;,  s: \u0026#39;0x3da7ab8323ab485741f9d1fdaae7a9c22fd8969a1e52ea50d9f6ab477de1cbbf\u0026#39;,  from: \u0026#39;0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\u0026#39;,  confirmations: 0,  wait: [Function (anonymous)] } 查询是否mint成功\n\u0026gt; await contractWithSigner.tokenURI(0) \u0026#39;ipfs://Qmxxx\u0026#39; \u0026gt; await contractWithSigner.ownerOf(0) \u0026#39;0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\u0026#39; 11. 发送NFT \u0026gt; account2 = new ethers.Wallet(\u0026#39;0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d\u0026#39;,provider) ... \u0026gt; contractWithSigner.transferFrom(await account1.getAddress(), await account2.getAddress(), 0) {  type: 2,  chainId: 31337,  nonce: 3,  maxPriorityFeePerGas: BigNumber { _hex: \u0026#39;0x59682f00\u0026#39;, _isBigNumber: true },  maxFeePerGas: BigNumber { _hex: \u0026#39;0xac5e7c24\u0026#39;, _isBigNumber: true },  gasPrice: null,  gasLimit: BigNumber { _hex: \u0026#39;0xf791\u0026#39;, _isBigNumber: true },  to: \u0026#39;0xe7f1725E7734CE288F8367e1Bb143E90bb3F0512\u0026#39;,  value: BigNumber { _hex: \u0026#39;0x00\u0026#39;, _isBigNumber: true },  data: \u0026#39;0x23b872dd000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb9226600000000000000000000000070997970c51812dc3a010c7d01b50e0d17dc79c80000000000000000000000000000000000000000000000000000000000000000\u0026#39;,  accessList: [],  hash: \u0026#39;0x1179e89396f6c69b4f7cf5d14d673379bceca3ed86b0f4fefbe41da025aaaea9\u0026#39;,  v: 1,  r: \u0026#39;0x06f35287e21c087138b8fae72c9b4e2008aded4e3fab4021358481d8424bc36f\u0026#39;,  s: \u0026#39;0x3cd8285a2ea1d9554eee14b6c799aca543d0c40006d0b7bb4a004f58fb6aa3fc\u0026#39;,  from: \u0026#39;0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\u0026#39;,  confirmations: 0,  wait: [Function (anonymous)] } 查看NFT是否发送成功\n\u0026gt; await contractWithSigner.tokenURI(0) \u0026#39;ipfs://Qmxxx\u0026#39; \u0026gt; await contractWithSigner.ownerOf(0) \u0026#39;0x70997970C51812dc3A010C7d01b50e0d17dc79C8\u0026#39; ","permalink":"https://zhongxuqi.github.io/blockchain/2022-08-19/","summary":"1. 安装Hardhat npm install --save-dev hardhat 2. 初始化Hardhat工程 npx hardhat 3. 安装官方contract库 npm install @openzeppelin/contracts 4. 完成ERC721 NFT智能合约代码 目录contracts/DrawNFT.sol\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.4;  import \u0026#34;@openzeppelin/contracts/token/ERC721/ERC721.sol\u0026#34;; import \u0026#34;@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\u0026#34;; import \u0026#34;@openzeppelin/contracts/access/Ownable.sol\u0026#34;; import \u0026#34;@openzeppelin/contracts/utils/Counters.sol\u0026#34;;  contract DrawNFT is ERC721, ERC721URIStorage, Ownable {  using Counters for Counters.Counter;   Counters.Counter private _tokenIdCounter;   constructor() ERC721(\u0026#34;DrawNFT\u0026#34;, \u0026#34;DNFT\u0026#34;) {}   function safeMint(address to, string memory uri) public onlyOwner {  uint256 tokenId = _tokenIdCounter.","title":"用Hardhat开发智能合约，并发布ERC721 NFT"},{"content":"1. 安装Hardhat npm install --save-dev hardhat 2. 初始化Hardhat工程 npx hardhat 3. 安装官方contract库 npm install @openzeppelin/contracts 4. 完成Token智能合约代码 目录contracts/DrawToken.sol\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.4;  import \u0026#34;@openzeppelin/contracts/token/ERC20/ERC20.sol\u0026#34;; import \u0026#34;@openzeppelin/contracts/access/Ownable.sol\u0026#34;;  contract DrawToken is ERC20, Ownable {  constructor() ERC20(\u0026#34;DrawToken\u0026#34;, \u0026#34;DTK\u0026#34;) {}   function mint(address to, uint256 amount) public onlyOwner {  _mint(to, amount);  } } 5. 完成合约部署代码 目录scripts/deploy.ts\nimport { ethers } from \u0026#34;hardhat\u0026#34;;  async function main() {  // DrawToken  const DrawToken = await ethers.getContractFactory(\u0026#34;DrawToken\u0026#34;);  const drawToken = await DrawToken.deploy();  await drawToken.deployed();  console.log(`drawToken deployed to ${drawToken.address}`); }  // We recommend this pattern to be able to use async/await everywhere // and properly handle errors. main().catch((error) =\u0026gt; {  console.error(error);  process.exitCode = 1; }); 6. 启动本地私有链 npx hardhat node 7. 部署合约 npx hardhat run --network localhost scripts/deploy.ts 得到合约地址\ndrawToken deployed to 0x5FbDB2315678afecb367f032d93F642f64180aa3 8. 启动nodejs，并初始化环境 # node Welcome to Node.js v16.15.1. Type \u0026#34;.help\u0026#34; for more information. \u0026gt; const { ethers } = require(\u0026#34;ethers\u0026#34;); undefined \u0026gt; const provider = new ethers.providers.JsonRpcProvider(); undefined \u0026gt; account1 = new ethers.Wallet(\u0026#39;0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80\u0026#39;,provider) Wallet {  _isSigner: true,  _signingKey: [Function (anonymous)],  _mnemonic: [Function (anonymous)],  address: \u0026#39;0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\u0026#39;,  provider: JsonRpcProvider {  _isProvider: true,  _events: [],  _emitted: { block: -2 },  disableCcipRead: false,  formatter: Formatter { formats: [Object] },  anyNetwork: false,  _networkPromise: Promise {  [Object],  [Symbol(async_id_symbol)]: 47,  [Symbol(trigger_async_id_symbol)]: 5,  [Symbol(destroyed)]: [Object]  },  _maxInternalBlockNumber: -1024,  _lastBlockNumber: -2,  _maxFilterBlockRange: 10,  _pollingInterval: 4000,  _fastQueryDate: 0,  connection: { url: \u0026#39;http://localhost:8545\u0026#39; },  _nextId: 43,  _eventLoopCache: { detectNetwork: null, eth_chainId: null },  _network: { chainId: 31337, name: \u0026#39;unknown\u0026#39; }  } } 9. 初始化contract \u0026gt; abi = [{\u0026#34;inputs\u0026#34;:[],\u0026#34;stateMutability\u0026#34;:\u0026#34;nonpayable\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;constructor\u0026#34;},{\u0026#34;anonymous\u0026#34;:false,\u0026#34;inputs\u0026#34;:[{\u0026#34;indexed\u0026#34;:true,\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;owner\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;indexed\u0026#34;:true,\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;spender\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;indexed\u0026#34;:false,\u0026#34;internalType\u0026#34;:\u0026#34;uint256\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;value\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;uint256\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;Approval\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;event\u0026#34;},{\u0026#34;anonymous\u0026#34;:false,\u0026#34;inputs\u0026#34;:[{\u0026#34;indexed\u0026#34;:true,\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;previousOwner\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;indexed\u0026#34;:true,\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;newOwner\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;OwnershipTransferred\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;event\u0026#34;},{\u0026#34;anonymous\u0026#34;:false,\u0026#34;inputs\u0026#34;:[{\u0026#34;indexed\u0026#34;:true,\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;from\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;indexed\u0026#34;:true,\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;to\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;indexed\u0026#34;:false,\u0026#34;internalType\u0026#34;:\u0026#34;uint256\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;value\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;uint256\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;Transfer\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;event\u0026#34;},{\u0026#34;inputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;owner\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;spender\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;allowance\u0026#34;,\u0026#34;outputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;uint256\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;uint256\u0026#34;}],\u0026#34;stateMutability\u0026#34;:\u0026#34;view\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;spender\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;internalType\u0026#34;:\u0026#34;uint256\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;amount\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;uint256\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;approve\u0026#34;,\u0026#34;outputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;bool\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;bool\u0026#34;}],\u0026#34;stateMutability\u0026#34;:\u0026#34;nonpayable\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;account\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;balanceOf\u0026#34;,\u0026#34;outputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;uint256\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;uint256\u0026#34;}],\u0026#34;stateMutability\u0026#34;:\u0026#34;view\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[],\u0026#34;name\u0026#34;:\u0026#34;decimals\u0026#34;,\u0026#34;outputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;uint8\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;uint8\u0026#34;}],\u0026#34;stateMutability\u0026#34;:\u0026#34;view\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;spender\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;internalType\u0026#34;:\u0026#34;uint256\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;subtractedValue\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;uint256\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;decreaseAllowance\u0026#34;,\u0026#34;outputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;bool\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;bool\u0026#34;}],\u0026#34;stateMutability\u0026#34;:\u0026#34;nonpayable\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;spender\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;internalType\u0026#34;:\u0026#34;uint256\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;addedValue\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;uint256\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;increaseAllowance\u0026#34;,\u0026#34;outputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;bool\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;bool\u0026#34;}],\u0026#34;stateMutability\u0026#34;:\u0026#34;nonpayable\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;to\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;internalType\u0026#34;:\u0026#34;uint256\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;amount\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;uint256\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;mint\u0026#34;,\u0026#34;outputs\u0026#34;:[],\u0026#34;stateMutability\u0026#34;:\u0026#34;nonpayable\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[],\u0026#34;name\u0026#34;:\u0026#34;name\u0026#34;,\u0026#34;outputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;string\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;string\u0026#34;}],\u0026#34;stateMutability\u0026#34;:\u0026#34;view\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[],\u0026#34;name\u0026#34;:\u0026#34;owner\u0026#34;,\u0026#34;outputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;}],\u0026#34;stateMutability\u0026#34;:\u0026#34;view\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[],\u0026#34;name\u0026#34;:\u0026#34;renounceOwnership\u0026#34;,\u0026#34;outputs\u0026#34;:[],\u0026#34;stateMutability\u0026#34;:\u0026#34;nonpayable\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[],\u0026#34;name\u0026#34;:\u0026#34;symbol\u0026#34;,\u0026#34;outputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;string\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;string\u0026#34;}],\u0026#34;stateMutability\u0026#34;:\u0026#34;view\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[],\u0026#34;name\u0026#34;:\u0026#34;totalSupply\u0026#34;,\u0026#34;outputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;uint256\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;uint256\u0026#34;}],\u0026#34;stateMutability\u0026#34;:\u0026#34;view\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;to\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;internalType\u0026#34;:\u0026#34;uint256\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;amount\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;uint256\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;transfer\u0026#34;,\u0026#34;outputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;bool\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;bool\u0026#34;}],\u0026#34;stateMutability\u0026#34;:\u0026#34;nonpayable\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;from\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;to\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;},{\u0026#34;internalType\u0026#34;:\u0026#34;uint256\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;amount\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;uint256\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;transferFrom\u0026#34;,\u0026#34;outputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;bool\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;bool\u0026#34;}],\u0026#34;stateMutability\u0026#34;:\u0026#34;nonpayable\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;address\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;newOwner\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;address\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;transferOwnership\u0026#34;,\u0026#34;outputs\u0026#34;:[],\u0026#34;stateMutability\u0026#34;:\u0026#34;nonpayable\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;}] ... \u0026gt; contract = new ethers.Contract(\u0026#39;0x5FbDB2315678afecb367f032d93F642f64180aa3\u0026#39;,abi,account1) ... 调用合约基本方法\n\u0026gt; await contract.name() \u0026#39;DrawToken\u0026#39; \u0026gt; await contract.symbol() \u0026#39;DTK\u0026#39; 10. mint出token \u0026gt; contractWithSigner = contract.connect(account1) ... \u0026gt; contractWithSigner.mint(await account1.getAddress(),100) {  type: 2,  chainId: 31337,  nonce: 2,  maxPriorityFeePerGas: BigNumber { _hex: \u0026#39;0x59682f00\u0026#39;, _isBigNumber: true },  maxFeePerGas: BigNumber { _hex: \u0026#39;0xb5f20e1e\u0026#39;, _isBigNumber: true },  gasPrice: null,  gasLimit: BigNumber { _hex: \u0026#39;0x0116e2\u0026#39;, _isBigNumber: true },  to: \u0026#39;0x5FbDB2315678afecb367f032d93F642f64180aa3\u0026#39;,  value: BigNumber { _hex: \u0026#39;0x00\u0026#39;, _isBigNumber: true },  data: \u0026#39;0x40c10f19000000000000000000000000f39fd6e51aad88f6f4ce6ab8827279cfffb922660000000000000000000000000000000000000000000000000000000000000064\u0026#39;,  accessList: [],  hash: \u0026#39;0x3e0a661dc1656fc7d3be8033f2f6fd4ceec8b05ac328c37fb1769d813a1c8524\u0026#39;,  v: 1,  r: \u0026#39;0xff8f32375fcc5fb3d31634a5b604c8bc4d975b1b694611a4323609d990f944b0\u0026#39;,  s: \u0026#39;0x14a5b08e8afd9686c1c89962f490a82836dd8aa95cd6c9adcb611596cbc46c91\u0026#39;,  from: \u0026#39;0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\u0026#39;,  confirmations: 0,  wait: [Function (anonymous)] } 查询是否mint成功\n\u0026gt; balance = await contractWithSigner.balanceOf(await account1.getAddress()) BigNumber { _hex: \u0026#39;0x64\u0026#39;, _isBigNumber: true } \u0026gt; balance.toString() \u0026#39;100\u0026#39; 11. 发送Token \u0026gt; account2 = new ethers.Wallet(\u0026#39;0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d\u0026#39;,provider) ... \u0026gt; contractWithSigner.transfer(await account2.getAddress(), 50) {  type: 2,  chainId: 31337,  nonce: 3,  maxPriorityFeePerGas: BigNumber { _hex: \u0026#39;0x59682f00\u0026#39;, _isBigNumber: true },  maxFeePerGas: BigNumber { _hex: \u0026#39;0xac5e7c24\u0026#39;, _isBigNumber: true },  gasPrice: null,  gasLimit: BigNumber { _hex: \u0026#39;0xcc41\u0026#39;, _isBigNumber: true },  to: \u0026#39;0x5FbDB2315678afecb367f032d93F642f64180aa3\u0026#39;,  value: BigNumber { _hex: \u0026#39;0x00\u0026#39;, _isBigNumber: true },  data: \u0026#39;0xa9059cbb00000000000000000000000070997970c51812dc3a010c7d01b50e0d17dc79c80000000000000000000000000000000000000000000000000000000000000032\u0026#39;,  accessList: [],  hash: \u0026#39;0xe0d69fe8dbffbb507090d6bc62c4f9127d88b9f747c466fd5a8df8cd5e60690c\u0026#39;,  v: 0,  r: \u0026#39;0xed8ebd334cf1996a9e3021866aca03c50bf98ffbbbd4dccb15352baabc0c0b02\u0026#39;,  s: \u0026#39;0x706acb4a6f768c095d3ac56f51dd2c4502da8236f52c39137891250ddab5de8c\u0026#39;,  from: \u0026#39;0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266\u0026#39;,  confirmations: 0,  wait: [Function (anonymous)] } 查看Token是否发送成功\n\u0026gt; (await contractWithSigner.balanceOf(await account2.getAddress())).toString() \u0026#39;50\u0026#39; \u0026gt; (await contractWithSigner.balanceOf(await account1.getAddress())).toString() \u0026#39;50\u0026#39; ","permalink":"https://zhongxuqi.github.io/blockchain/2022-08-18/","summary":"1. 安装Hardhat npm install --save-dev hardhat 2. 初始化Hardhat工程 npx hardhat 3. 安装官方contract库 npm install @openzeppelin/contracts 4. 完成Token智能合约代码 目录contracts/DrawToken.sol\n// SPDX-License-Identifier: MIT pragma solidity ^0.8.4;  import \u0026#34;@openzeppelin/contracts/token/ERC20/ERC20.sol\u0026#34;; import \u0026#34;@openzeppelin/contracts/access/Ownable.sol\u0026#34;;  contract DrawToken is ERC20, Ownable {  constructor() ERC20(\u0026#34;DrawToken\u0026#34;, \u0026#34;DTK\u0026#34;) {}   function mint(address to, uint256 amount) public onlyOwner {  _mint(to, amount);  } } 5. 完成合约部署代码 目录scripts/deploy.ts\nimport { ethers } from \u0026#34;hardhat\u0026#34;;  async function main() {  // DrawToken  const DrawToken = await ethers.","title":"用Hardhat开发智能合约，并发布ERC20 Token"},{"content":"1. 对message进行签名 from eth_account.messages import encode_defunct from web3 import Web3 from eth_keys import keys  KEY = ... # 填写账户私钥 w3 = Web3(Web3.HTTPProvider(\u0026lt;input eth node url/\u0026gt;)) # 请填写以太坊的节点url account = w3.eth.account.from_key(KEY) print(\u0026#39;address: \u0026#39;, account.address) rawText = \u0026#39;hello\u0026#39; # 签名message signedMessage = account.sign_message(encode_defunct(text=rawText)) print(\u0026#39;message hash: \u0026#39;, signedMessage.messageHash.hex()) # print(signedMessage) print(\u0026#39;v: \u0026#39;, int(signedMessage.v)) print(\u0026#39;r: \u0026#39;, hex(signedMessage.r)) print(\u0026#39;s: \u0026#39;, hex(signedMessage.s)) print(\u0026#39;signature: \u0026#39;, signedMessage.signature.hex()) print(w3.eth.account.recover_message(encode_defunct(text=rawText), signature=signedMessage.signature)) 2. 执行脚本，得到 address: 0x1c74c86906d91766e143e1d009C8604b66001363 message hash: 0x50b2c43fd39106bafbba0da34fc430e1f91e3c96ea2acee2bc34119f92b37750 v: 28 r: 0x5a0121bea4f2c1e9e6aad76bd3e06191a533c0b53a77df31e3b6310dbf4f698f s: 0x17216a4bfd7cf812bf2a6d9b44122c807880a5cb3de403d4baa8e0fb352189dd signature: 0x5a0121bea4f2c1e9e6aad76bd3e06191a533c0b53a77df31e3b6310dbf4f698f17216a4bfd7cf812bf2a6d9b44122c807880a5cb3de403d4baa8e0fb352189dd1c 0x1c74c86906d91766e143e1d009C8604b66001363 3. 智能合约代码 pragma solidity ^0.8.13;  contract VerifySign{  //公匙：0x1c74c86906d91766e143e1d009C8604b66001363  //sha3(msg): 0x4e03657aea45a94fc7d47ba826c8d667c0d1e6e33a64a036ec44f58fa12d6c45 (web3.sha3(\u0026#34;abc\u0026#34;);)  //签名后的数据：0x7eeb34fb6770d2b935de3657652e8060033ec47f57d10acbcc6a4b4d69f82db12d8ddd81e67a01a4a51a0e658760e895bab90a24cc0d7803800098be779ea1d91c   //将原始数据按段切割出来指定长度  function slice(bytes memory data, uint start, uint len) private returns (bytes memory) {  bytes memory b = new bytes(len);   for(uint i = 0; i \u0026lt; len; i++){  b[i] = data[i + start];  }   return b;  }   //bytes转换为bytes32  function bytesToBytes32(bytes memory source) private returns (bytes32 result) {  assembly {  result := mload(add(source, 32))  }  }   // \u0026#34;\\x19Ethereum Signed Message:\\n{{len}}\u0026#34;  function VerifyMessageV1(bytes32 messageHash, uint8 _v, bytes32 _r, bytes32 _s) public pure returns (address signer) {  signer = ecrecover(messageHash, _v, _r, _s);  }   address addr;  bytes32 r; bytes32 s; uint8 v;  function VerifyMessageV2(bytes32 messageHash, bytes memory signedString) public {  r = bytesToBytes32(slice(signedString, 0, 32));  s = bytesToBytes32(slice(signedString, 32, 32));  v = uint8(slice(signedString, 64, 1)[0]);  addr = ecrecover(messageHash, v, r, s);  }   function getSignCheckResult() public view returns (address _addr, bytes32 _r, bytes32 _s, uint8 _v){  _addr = addr;  _v = v;  _r = r;  _s = s;  } } 4. 部署智能合约到remix https://remix.ethereum.org/\n5. 执行VerifyMessageV1函数 输入参数：\n{  \u0026#34;messageHash\u0026#34;: \u0026#34;0x50b2c43fd39106bafbba0da34fc430e1f91e3c96ea2acee2bc34119f92b37750\u0026#34;,  \u0026#34;signedString\u0026#34;: \u0026#34;28\u0026#34;,  \u0026#34;_r\u0026#34;: \u0026#34;0x5a0121bea4f2c1e9e6aad76bd3e06191a533c0b53a77df31e3b6310dbf4f698f\u0026#34;,  \u0026#34;_s\u0026#34;: \u0026#34;0x17216a4bfd7cf812bf2a6d9b44122c807880a5cb3de403d4baa8e0fb352189dd\u0026#34;, } 返回结果：\n{  \u0026#34;signer\u0026#34;: \u0026#34;0x1c74c86906d91766e143e1d009C8604b66001363\u0026#34;, } signer和签名账户的地址一致\n6. 执行VerifyMessageV2函数 输入参数：\n{  \u0026#34;messageHash\u0026#34;: \u0026#34;0x50b2c43fd39106bafbba0da34fc430e1f91e3c96ea2acee2bc34119f92b37750\u0026#34;,  \u0026#34;signedString\u0026#34;: \u0026#34;0x5a0121bea4f2c1e9e6aad76bd3e06191a533c0b53a77df31e3b6310dbf4f698f17216a4bfd7cf812bf2a6d9b44122c807880a5cb3de403d4baa8e0fb352189dd1c\u0026#34;, } 执行getSignCheckResult，返回结果：\n{  \u0026#34;_addr\u0026#34;: \u0026#34;0x1c74c86906d91766e143e1d009C8604b66001363\u0026#34;,  \u0026#34;_r\u0026#34;: \u0026#34;0x5a0121bea4f2c1e9e6aad76bd3e06191a533c0b53a77df31e3b6310dbf4f698f\u0026#34;,  \u0026#34;_s\u0026#34;: \u0026#34;0x17216a4bfd7cf812bf2a6d9b44122c807880a5cb3de403d4baa8e0fb352189dd\u0026#34;,  \u0026#34;_v\u0026#34;: \u0026#34;28\u0026#34;, } _addr和签名账户的地址一致\n","permalink":"https://zhongxuqi.github.io/blockchain/2022-03-27/","summary":"1. 对message进行签名 from eth_account.messages import encode_defunct from web3 import Web3 from eth_keys import keys  KEY = ... # 填写账户私钥 w3 = Web3(Web3.HTTPProvider(\u0026lt;input eth node url/\u0026gt;)) # 请填写以太坊的节点url account = w3.eth.account.from_key(KEY) print(\u0026#39;address: \u0026#39;, account.address) rawText = \u0026#39;hello\u0026#39; # 签名message signedMessage = account.sign_message(encode_defunct(text=rawText)) print(\u0026#39;message hash: \u0026#39;, signedMessage.messageHash.hex()) # print(signedMessage) print(\u0026#39;v: \u0026#39;, int(signedMessage.v)) print(\u0026#39;r: \u0026#39;, hex(signedMessage.r)) print(\u0026#39;s: \u0026#39;, hex(signedMessage.s)) print(\u0026#39;signature: \u0026#39;, signedMessage.signature.hex()) print(w3.eth.account.recover_message(encode_defunct(text=rawText), signature=signedMessage.signature)) 2. 执行脚本，得到 address: 0x1c74c86906d91766e143e1d009C8604b66001363 message hash: 0x50b2c43fd39106bafbba0da34fc430e1f91e3c96ea2acee2bc34119f92b37750 v: 28 r: 0x5a0121bea4f2c1e9e6aad76bd3e06191a533c0b53a77df31e3b6310dbf4f698f s: 0x17216a4bfd7cf812bf2a6d9b44122c807880a5cb3de403d4baa8e0fb352189dd signature: 0x5a0121bea4f2c1e9e6aad76bd3e06191a533c0b53a77df31e3b6310dbf4f698f17216a4bfd7cf812bf2a6d9b44122c807880a5cb3de403d4baa8e0fb352189dd1c 0x1c74c86906d91766e143e1d009C8604b66001363 3.","title":"Eth智能合约签名校验 - 可用于实现多签合约"},{"content":"1. 下载 $ git clone https://github.com/ethereum/go-ethereum.git 2. 编译 $ cd go-ethereum $ make geth 把./build/bin/geth添加到可执行路径中\n3. 配置初始状态 保存配置到genesis.json文件\n{  \u0026#34;config\u0026#34;: {  \u0026#34;chainId\u0026#34;: 7777,  \u0026#34;homesteadBlock\u0026#34;: 0,  \u0026#34;eip150Block\u0026#34;: 0,  \u0026#34;eip155Block\u0026#34;: 0,  \u0026#34;eip158Block\u0026#34;: 0,  \u0026#34;byzantiumBlock\u0026#34;: 0,  \u0026#34;constantinopleBlock\u0026#34;: 0,  \u0026#34;petersburgBlock\u0026#34;: 0,  \u0026#34;ethash\u0026#34;: {}  },  \u0026#34;difficulty\u0026#34;: \u0026#34;1\u0026#34;,  \u0026#34;gasLimit\u0026#34;: \u0026#34;8000000\u0026#34;,  \u0026#34;alloc\u0026#34;: {  \u0026#34;7df9a875a174b3bc565e6424a0050ebc1b2d1d82\u0026#34;: { \u0026#34;balance\u0026#34;: \u0026#34;300000\u0026#34; },  \u0026#34;f41c74c9ae680c1aa78f42e5647a62f353b7bdde\u0026#34;: { \u0026#34;balance\u0026#34;: \u0026#34;400000\u0026#34; }  } } 执行geth init --datadir data genesis.json，初始化以太坊配置。\n4. 运行以太坊节点 执行geth --datadir data --nodiscover --mine console，节点启动。\n5. 创建账户 在以太坊console执行如下命令\n\u0026gt; personal.newAccount() Passphrase: Repeat passphrase: INFO [03-15|17:46:52.995] Your new key was generated address=0x45281eb7BBaA41FeF62D40aE881378c14335C1Cf WARN [03-15|17:46:52.996] Please backup your key file! path=/Users/xuqizhong/tmp/eth/data/keystore/UTC--2022-03-15T09-46-51.983819000Z--45281eb7bbaa41fef62d40ae881378c14335c1cf WARN [03-15|17:46:52.996] Please remember your password! \u0026#34;0x45281eb7bbaa41fef62d40ae881378c14335c1cf\u0026#34; 执行如下命令，可以查询有哪些账户\n\u0026gt; personal.listAccounts [\u0026#34;0x45281eb7bbaa41fef62d40ae881378c14335c1cf\u0026#34;, \u0026#34;0x96b638097bb4dd40d9bca6f1197b8d24b1705cfa\u0026#34;] 6. 挖矿 执行挖矿命令\n\u0026gt; miner.start() 暂停挖矿命令\n\u0026gt; miner.stop() 查询钱包余额\n\u0026gt; web3.fromWei(eth.getBalance(\u0026#34;0x45281eb7bbaa41fef62d40ae881378c14335c1cf\u0026#34;),\u0026#34;ether\u0026#34;) 196 7. 发送交易 首先需要解锁账户0\n\u0026gt; personal.unlockAccount(eth.accounts[0]) Unlock account 0x45281eb7bbaa41fef62d40ae881378c14335c1cf Passphrase: true 发起交易\n\u0026gt; eth.sendTransaction({from:eth.accounts[0],to:eth.accounts[1],value:web3.toWei(10,\u0026#39;ether\u0026#39;)}) INFO [03-15|18:29:11.590] Setting new local account address=0x45281eb7BBaA41FeF62D40aE881378c14335C1Cf INFO [03-15|18:29:11.591] Submitted transaction hash=0xef11db5b652c6402a2569843c7b364cda8628e84f86efe51d5b5b674cf6caa23 from=0x45281eb7BBaA41FeF62D40aE881378c14335C1Cf nonce=0 recipient=0x96b638097Bb4dD40d9bca6f1197b8d24B1705cfa value=10,000,000,000,000,000,000 \u0026#34;0xef11db5b652c6402a2569843c7b364cda8628e84f86efe51d5b5b674cf6caa23\u0026#34; 查询账户1的余额\n\u0026gt; web3.fromWei(eth.getBalance(eth.accounts[1]),\u0026#39;ether\u0026#39;) 10 8. 编写智能合约 实现一个简单的智能合约demo.sol\npragma solidity \u0026gt;=0.7.0 \u0026lt;0.9.0;  contract SimpleStorage {  uint storedData;   function set(uint x) public {  storedData = x;  }   function get() public view returns (uint) {  return storedData;  } } 编译智能合约\n\u0026gt; solc --optimize --combined-json abi,bin demo.sol solc --optimize --combined-json abi,bin demo.sol Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing \u0026#34;SPDX-License-Identifier: \u0026lt;SPDX-License\u0026gt;\u0026#34; to each source file. Use \u0026#34;SPDX-License-Identifier: UNLICENSED\u0026#34; for non-open-source code. Please see https://spdx.org for more information. --\u0026gt; demo.sol  {\u0026#34;contracts\u0026#34;:{\u0026#34;demo.sol:SimpleStorage\u0026#34;:{\u0026#34;abi\u0026#34;:[{\u0026#34;inputs\u0026#34;:[],\u0026#34;name\u0026#34;:\u0026#34;get\u0026#34;,\u0026#34;outputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;uint256\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;uint256\u0026#34;}],\u0026#34;stateMutability\u0026#34;:\u0026#34;view\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;uint256\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;x\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;uint256\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;set\u0026#34;,\u0026#34;outputs\u0026#34;:[],\u0026#34;stateMutability\u0026#34;:\u0026#34;nonpayable\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;}],\u0026#34;bin\u0026#34;:\u0026#34;6080604052348015600f57600080fd5b5060ac8061001e6000396000f3fe6080604052348015600f57600080fd5b506004361060325760003560e01c806360fe47b11460375780636d4ce63c146049575b600080fd5b60476042366004605e565b600055565b005b60005460405190815260200160405180910390f35b600060208284031215606f57600080fd5b503591905056fea264697066735822122026c14d5b811591c48b9fef3864b4577cbbc2ebd0e5ebc07b7d54847f206eb69564736f6c634300080c0033\u0026#34;}},\u0026#34;version\u0026#34;:\u0026#34;0.8.12+commit.f00d7308.Darwin.appleclang\u0026#34;} 9. 部署智能合约 解锁账户\n\u0026gt; personal.unlockAccount(\u0026#34;0x45281eb7bbaa41fef62d40ae881378c14335c1cf\u0026#34;) Unlock account 0x45281eb7bbaa41fef62d40ae881378c14335c1cf Passphrase: true 通过web3.eth.contract的new方法发起部署合约的交易\n\u0026gt; var storageContractJson = {\u0026#34;contracts\u0026#34;:{\u0026#34;demo.sol:SimpleStorage\u0026#34;:{\u0026#34;abi\u0026#34;:[{\u0026#34;inputs\u0026#34;:[],\u0026#34;name\u0026#34;:\u0026#34;get\u0026#34;,\u0026#34;outputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;uint256\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;uint256\u0026#34;}],\u0026#34;stateMutability\u0026#34;:\u0026#34;view\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;},{\u0026#34;inputs\u0026#34;:[{\u0026#34;internalType\u0026#34;:\u0026#34;uint256\u0026#34;,\u0026#34;name\u0026#34;:\u0026#34;x\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;uint256\u0026#34;}],\u0026#34;name\u0026#34;:\u0026#34;set\u0026#34;,\u0026#34;outputs\u0026#34;:[],\u0026#34;stateMutability\u0026#34;:\u0026#34;nonpayable\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;function\u0026#34;}],\u0026#34;bin\u0026#34;:\u0026#34;6080604052348015600f57600080fd5b5060ac8061001e6000396000f3fe6080604052348015600f57600080fd5b506004361060325760003560e01c806360fe47b11460375780636d4ce63c146049575b600080fd5b60476042366004605e565b600055565b005b60005460405190815260200160405180910390f35b600060208284031215606f57600080fd5b503591905056fea264697066735822122026c14d5b811591c48b9fef3864b4577cbbc2ebd0e5ebc07b7d54847f206eb69564736f6c634300080c0033\u0026#34;}},\u0026#34;version\u0026#34;:\u0026#34;0.8.12+commit.f00d7308.Darwin.appleclang\u0026#34;} undefined \u0026gt; var storageContract = eth.contract(storageContractJson.contracts[\u0026#34;demo.sol:SimpleStorage\u0026#34;].abi) undefined \u0026gt; var storageContractObj = {from:eth.accounts[0],data:\u0026#34;0x\u0026#34;+storageContractJson.contracts[\u0026#34;demo.sol:SimpleStorage\u0026#34;].bin,gas:1000000} undefined \u0026gt; \u0026gt; var storageContractIns = storageContract.new(storageContractObj) INFO [03-16|11:37:55.925] Setting new local account address=0x45281eb7BBaA41FeF62D40aE881378c14335C1Cf INFO [03-16|11:37:55.926] Submitted contract creation hash=0xa8c86633956bea5f8532734bd76a3125ee2f81c0ddf5308762651c94c99cd957 from=0x45281eb7BBaA41FeF62D40aE881378c14335C1Cf nonce=1 contract=0xf00a6AAA995c8adcC7b0A6d2A044827c58b6cdb3 value=0 undefined 查看交易池状态\n\u0026gt; txpool.status {  pending: 1,  queued: 0 } \u0026gt; txpool.inspect.pending {  0x45281eb7BBaA41FeF62D40aE881378c14335C1Cf: {  1: \u0026#34;contract creation: 0 wei + 1000000 gas × 1000000000 wei\u0026#34;  } } 可以看到有一个交易待处理，开始挖矿\n\u0026gt; miner.start(1);admin.sleepBlocks(1);miner.stop(); INFO [03-16|11:40:45.910] Updated mining threads threads=1 INFO [03-16|11:40:49.606] Successfully sealed new block number=104 sealhash=b80b30..539c7f hash=8fe8f6..e601c7 elapsed=2m50.695s INFO [03-16|11:40:49.606] 🔨 mined potential block number=104 hash=8fe8f6..e601c7 INFO [03-16|11:40:49.607] Commit new sealing work number=105 sealhash=d85721..564878 uncles=0 txs=0 gas=0 fees=0 elapsed=\u0026#34;126.458µs\u0026#34; INFO [03-16|11:40:49.607] Commit new sealing work number=105 sealhash=d85721..564878 uncles=0 txs=0 gas=0 fees=0 elapsed=\u0026#34;245.25µs\u0026#34; null \u0026gt; txpool.status {  pending: 0,  queued: 0 } 查看合约地址\n\u0026gt; storageContractIns {  abi: [{  inputs: [],  name: \u0026#34;get\u0026#34;,  outputs: [{...}],  stateMutability: \u0026#34;view\u0026#34;,  type: \u0026#34;function\u0026#34;  }, {  inputs: [{...}],  name: \u0026#34;set\u0026#34;,  outputs: [],  stateMutability: \u0026#34;nonpayable\u0026#34;,  type: \u0026#34;function\u0026#34;  }],  address: \u0026#34;0xf00a6aaa995c8adcc7b0a6d2a044827c58b6cdb3\u0026#34;,  transactionHash: \u0026#34;0xa8c86633956bea5f8532734bd76a3125ee2f81c0ddf5308762651c94c99cd957\u0026#34;,  allEvents: function bound(),  get: function bound(),  set: function bound() } 查看部署合约交易详情\n\u0026gt; eth.getTransactionReceipt(storageContractIns.transactionHash) {  blockHash: \u0026#34;0x8fe8f6dc26b38c87287de5fab28b1b3983dd7b2b47ebb59eb69f60c8b4e601c7\u0026#34;,  blockNumber: 104,  contractAddress: \u0026#34;0xf00a6aaa995c8adcc7b0a6d2a044827c58b6cdb3\u0026#34;,  cumulativeGasUsed: 100327,  effectiveGasPrice: 1000000000,  from: \u0026#34;0x45281eb7bbaa41fef62d40ae881378c14335c1cf\u0026#34;,  gasUsed: 100327,  logs: [],  logsBloom: \u0026#34;0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\u0026#34;,  status: \u0026#34;0x1\u0026#34;,  to: null,  transactionHash: \u0026#34;0xa8c86633956bea5f8532734bd76a3125ee2f81c0ddf5308762651c94c99cd957\u0026#34;,  transactionIndex: 0,  type: \u0026#34;0x0\u0026#34; } 获取合约地址\n\u0026gt; var storageContractInsAddress = eth.getTransactionReceipt(storageContractIns.transactionHash).contractAddress undefined \u0026gt; storageContractInsAddress \u0026#34;0xf00a6aaa995c8adcc7b0a6d2a044827c58b6cdb3\u0026#34; 获取合约实例\n\u0026gt; var storageContractIns = storageContract.at(storageContractInsAddress) undefined \u0026gt; storageContractIns {  abi: [{  inputs: [],  name: \u0026#34;get\u0026#34;,  outputs: [{...}],  stateMutability: \u0026#34;view\u0026#34;,  type: \u0026#34;function\u0026#34;  }, {  inputs: [{...}],  name: \u0026#34;set\u0026#34;,  outputs: [],  stateMutability: \u0026#34;nonpayable\u0026#34;,  type: \u0026#34;function\u0026#34;  }],  address: \u0026#34;0xf00a6aaa995c8adcc7b0a6d2a044827c58b6cdb3\u0026#34;,  transactionHash: null,  allEvents: function bound(),  get: function bound(),  set: function bound() } 调用合约get方法\n\u0026gt; storageContractIns.get.call() 0 调用合约set方法\n\u0026gt; storageContractIns.set.sendTransaction(77,{from:eth.accounts[0],gas:1000000}) INFO [03-16|11:51:41.077] Submitted transaction hash=0xf431e2d1e2dbf042dca26570d213415c2ccf72a0272a89c028db7a802b38a9f0 from=0x45281eb7BBaA41FeF62D40aE881378c14335C1Cf nonce=2 recipient=0xf00a6AAA995c8adcC7b0A6d2A044827c58b6cdb3 value=0 \u0026#34;0xf431e2d1e2dbf042dca26570d213415c2ccf72a0272a89c028db7a802b38a9f0\u0026#34; \u0026gt; txpool.status {  pending: 1,  queued: 0 } \u0026gt; miner.start(1);admin.sleepBlocks(1);miner.stop(); INFO [03-16|11:52:18.540] Updated mining threads threads=1 INFO [03-16|11:52:18.540] Transaction pool price threshold updated price=1,000,000,000 INFO [03-16|11:52:18.540] Commit new sealing work number=105 sealhash=67a38b..47fa30 uncles=0 txs=0 gas=0 fees=0 elapsed=\u0026#34;265.708µs\u0026#34; INFO [03-16|11:52:18.541] Commit new sealing work number=105 sealhash=e82e4a..e120c7 uncles=0 txs=1 gas=41654 fees=4.1654e-05 elapsed=\u0026#34;688.625µs\u0026#34; INFO [03-16|11:52:20.048] Successfully sealed new block number=105 sealhash=e82e4a..e120c7 hash=5300e6..eced57 elapsed=1.507s INFO [03-16|11:52:20.048] 🔨 mined potential block number=105 hash=5300e6..eced57 INFO [03-16|11:52:20.048] Commit new sealing work number=106 sealhash=cf5725..46077d uncles=0 txs=0 gas=0 fees=0 elapsed=\u0026#34;76.375µs\u0026#34; INFO [03-16|11:52:20.048] Commit new sealing work number=106 sealhash=cf5725..46077d uncles=0 txs=0 gas=0 fees=0 elapsed=\u0026#34;126.084µs\u0026#34; null \u0026gt; txpool.status {  pending: 0,  queued: 0 } 获取存储结果\n\u0026gt; storageContractIns.get.call() 77 ","permalink":"https://zhongxuqi.github.io/blockchain/2022-03-15/","summary":"1. 下载 $ git clone https://github.com/ethereum/go-ethereum.git 2. 编译 $ cd go-ethereum $ make geth 把./build/bin/geth添加到可执行路径中\n3. 配置初始状态 保存配置到genesis.json文件\n{  \u0026#34;config\u0026#34;: {  \u0026#34;chainId\u0026#34;: 7777,  \u0026#34;homesteadBlock\u0026#34;: 0,  \u0026#34;eip150Block\u0026#34;: 0,  \u0026#34;eip155Block\u0026#34;: 0,  \u0026#34;eip158Block\u0026#34;: 0,  \u0026#34;byzantiumBlock\u0026#34;: 0,  \u0026#34;constantinopleBlock\u0026#34;: 0,  \u0026#34;petersburgBlock\u0026#34;: 0,  \u0026#34;ethash\u0026#34;: {}  },  \u0026#34;difficulty\u0026#34;: \u0026#34;1\u0026#34;,  \u0026#34;gasLimit\u0026#34;: \u0026#34;8000000\u0026#34;,  \u0026#34;alloc\u0026#34;: {  \u0026#34;7df9a875a174b3bc565e6424a0050ebc1b2d1d82\u0026#34;: { \u0026#34;balance\u0026#34;: \u0026#34;300000\u0026#34; },  \u0026#34;f41c74c9ae680c1aa78f42e5647a62f353b7bdde\u0026#34;: { \u0026#34;balance\u0026#34;: \u0026#34;400000\u0026#34; }  } } 执行geth init --datadir data genesis.","title":"打造以太坊私有链，合约的部署与使用"},{"content":"docker是目前大红大紫的云计算技术，它极大的简化项目的部署并提高计算资源的利用率；同样，它也能用于项目的开发，提高代码的开发效率。\n用docker进行项目开发的优点  不会污染当前环境，包括环境变量和临时文件。 方便得进行第三方库的版本管理，例如可以分别构建go1.7和go1.8的docker image，编译的时候只用切换docker image就可以实现用不同的go版本进行代码编译。 团队合作中，可以方便地保证大家使用的编译环境是一样的，避免了很多不必要的问题。  用docker进行开发的具体实现步骤 以lowtea为例子，介绍如何用docker进行项目开发。\n构建docker image 前端docker image的Dockerfile，构建出前端运行环境image。\nFROMhub.c.163.com/library/node:6.10.0MAINTAINERzhongxuqiRUN npm install -g bower \u0026amp;\u0026amp; npm install -g gulp \u0026amp;\u0026amp; mkdir /workspaceWORKDIR/workspace后端docker image的Dockerfile，构建出后端运行环境的image。\nFROMhub.c.163.com/library/golang:1.7.4MAINTAINERzhongxuqiRUN mkdir /golang \u0026amp;\u0026amp; export GOPATH=/golang \u0026amp;\u0026amp; mkdir /workspaceWORKDIR/workspace编写Makefile SHELL=/bin/bash  lowtea-frontend: \tcd lowtea/front \u0026amp;\u0026amp; npm install \u0026amp;\u0026amp; gulp serve  docker-lowtea-frontend: \tcd lowtea/front \u0026amp;\u0026amp; npm install \u0026amp;\u0026amp; gulp serve -p http://lowtea-backend:7070  lowtea-backend: \tcd lowtea \u0026amp;\u0026amp; source env.sh \u0026amp;\u0026amp; make run 编写docker-compose.yml base-dc.yml\nversion: \u0026#34;2\u0026#34; services:  mongodb:  image: hub.c.163.com/library/mongo  ports:  - \u0026#34;27017\u0026#34; default-dc.yml\nversion: \u0026#34;2\u0026#34; services:  lowtea-backend:  image: \u0026#34;hub.c.163.com/zhongxuqi/go-base:latest\u0026#34;  ports:  - \u0026#34;7070:7070\u0026#34;  external_links:  - mongodb  volumes:  - /Users/zhongxuqi/ProjectFiles/github:/workspace  working_dir: /workspace  command: bash -c \u0026#34;make lowtea-backend\u0026#34;  lowtea-frontend:  image: \u0026#34;hub.c.163.com/zhongxuqi/frontend-base:latest\u0026#34;  ports:  - \u0026#34;3000:3000\u0026#34;  - \u0026#34;3001:3001\u0026#34;  volumes:  - /Users/zhongxuqi/ProjectFiles/github:/workspace  working_dir: /workspace  links:  - lowtea-backend  command: bash -c \u0026#34;make docker-lowtea-frontend\u0026#34; 启动服务 docker-compose -f base-dc.yml up -d docker-compose -f default-dc.yml up -d ","permalink":"https://zhongxuqi.github.io/tools/2017-04-07/","summary":"docker是目前大红大紫的云计算技术，它极大的简化项目的部署并提高计算资源的利用率；同样，它也能用于项目的开发，提高代码的开发效率。\n用docker进行项目开发的优点  不会污染当前环境，包括环境变量和临时文件。 方便得进行第三方库的版本管理，例如可以分别构建go1.7和go1.8的docker image，编译的时候只用切换docker image就可以实现用不同的go版本进行代码编译。 团队合作中，可以方便地保证大家使用的编译环境是一样的，避免了很多不必要的问题。  用docker进行开发的具体实现步骤 以lowtea为例子，介绍如何用docker进行项目开发。\n构建docker image 前端docker image的Dockerfile，构建出前端运行环境image。\nFROMhub.c.163.com/library/node:6.10.0MAINTAINERzhongxuqiRUN npm install -g bower \u0026amp;\u0026amp; npm install -g gulp \u0026amp;\u0026amp; mkdir /workspaceWORKDIR/workspace后端docker image的Dockerfile，构建出后端运行环境的image。\nFROMhub.c.163.com/library/golang:1.7.4MAINTAINERzhongxuqiRUN mkdir /golang \u0026amp;\u0026amp; export GOPATH=/golang \u0026amp;\u0026amp; mkdir /workspaceWORKDIR/workspace编写Makefile SHELL=/bin/bash  lowtea-frontend: \tcd lowtea/front \u0026amp;\u0026amp; npm install \u0026amp;\u0026amp; gulp serve  docker-lowtea-frontend: \tcd lowtea/front \u0026amp;\u0026amp; npm install \u0026amp;\u0026amp; gulp serve -p http://lowtea-backend:7070  lowtea-backend: \tcd lowtea \u0026amp;\u0026amp; source env.","title":"使用docker进行项目开发"},{"content":"目前市面上有很多APM厂商，用户只用集成Android SDK，写一行启动代码就可以轻松实现对APP网络请求的监听，非常神奇。本文就介绍一种可以实现该功能的技术，实现对APP网络请求的全量监听。\n需求  SDK集成后能实现对APP网络请求的监听。 接入无成本，只需要少量的启动代码，不需要修改已有的代码。  可以实现监听网络请求的技术方案 1. 实现整个http网络框架，让用户去调用。 该方案实现成本过高，而且接入成本也很高，基本不能实现。\n2. Android热修复方案 目前以Dexposed为代表的热修复方案无法支持ART虚拟机，不能用于5.0以上的Android操作系统；以Nova为代表的热修复方案需要首先被加载并且无法对修改现有类进行修改，不能用于sdk。\n3. Java AOP编程技术 该方案能成功实现对Java的Hook，而且灵活可控，能够有效实现对API的监听。\n现有Java AOP技术  Apt Aspectj Javassit  它们的区别如下图所示 本文采用Aspectj来实现网络请求监听SDK\nAndroid Aspectj插件 Android Aspectj Git Repo\n接入步骤如下所示：  关闭Android Intant Run  修改Project的.gradle文件  修改Module的.gradle文件   API Hook语法介绍 常用的annotation有Before、Around、After，分别是在目标函数(需要进行aspectj hook的函数)执行的前、中、后期进行hook。主要的hook方式分为call和execution两种，它们区别如下所示: call\n// \u0026lt;------- before call JoinPoint targetFunc() // \u0026lt;------ around call JoinPoint // \u0026lt;------- after call JoinPoint exection\ntargetFunc() {  // \u0026lt;------- before execution JoinPoint  ... // \u0026lt;------ around exection JoinPoint  // \u0026lt;------- after exection JoinPoint } 下面将通过一段代码来演示： Activity.java\npublic class MainActivity extends AppCompatActivity { private static final String TAG = \u0026#34;MainActivity\u0026#34;; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); new Example().SayHelloWord(); } } Example.java\npublic class Example { private static final String TAG = \u0026#34;Example\u0026#34;; public void SayHelloWord() { Log.i(TAG, \u0026#34;Hello world!\u0026#34;); } } AspecjExample.java\n@Aspect public class AspecjExample { private static final String TAG = \u0026#34;AspecjExample\u0026#34;; protected static final AspecjExample instance = new AspecjExample(); @Before(\u0026#34;call(* testapp.aspectjtest.Example.SayHelloWord(..))\u0026#34;) public void BeforeCall(JoinPoint joinPoint) throws Throwable { Log.i(TAG, \u0026#34;Aspectj Before call SayHelloWord\u0026#34;); } @Before(\u0026#34;execution(* testapp.aspectjtest.Example.SayHelloWord(..))\u0026#34;) public void BeforeExecution(JoinPoint joinPoint) throws Throwable { Log.i(TAG, \u0026#34;Aspectj Before execution SayHelloWord\u0026#34;); } @Around(\u0026#34;call(* testapp.aspectjtest.Example.SayHelloWord(..))\u0026#34;) public Object AroundCall(ProceedingJoinPoint joinPoint) throws Throwable { Log.i(TAG, \u0026#34;Aspectj Around start call SayHelloWord\u0026#34;); Object ret = joinPoint.proceed(); Log.i(TAG, \u0026#34;Aspectj Around end call SayHelloWord\u0026#34;); return ret; } @Around(\u0026#34;execution(* testapp.aspectjtest.Example.SayHelloWord(..))\u0026#34;) public Object AroundExecution(ProceedingJoinPoint joinPoint) throws Throwable { Log.i(TAG, \u0026#34;Aspectj Around start execution SayHelloWord\u0026#34;); Object ret = joinPoint.proceed(); Log.i(TAG, \u0026#34;Aspectj Around end execution SayHelloWord\u0026#34;); return ret; } @After(\u0026#34;call(* testapp.aspectjtest.Example.SayHelloWord(..))\u0026#34;) public void AfterCall(JoinPoint joinPoint) throws Throwable { Log.i(TAG, \u0026#34;Aspectj After call SayHelloWord\u0026#34;); } @After(\u0026#34;execution(* testapp.aspectjtest.Example.SayHelloWord(..))\u0026#34;) public void AfterExecution(JoinPoint joinPoint) throws Throwable { Log.i(TAG, \u0026#34;Aspectj After execution SayHelloWord\u0026#34;); } public static AspecjExample aspectOf() { return instance; } } 输入结果为： 如何实现对网络请求API的监听 监听URLConnection: @Around(\u0026#34;call(* java.net.URL+.openConnection(..))\u0026#34;) public Object onHttpURLOpenConnect(ProceedingJoinPoint joinPoint) throws Throwable { ... // 建立Http连接，并获取主机IP和DNS时间 } @Around(\u0026#34;call(* java.net.URLConnection+.getInputStream(..))\u0026#34;) public Object onHttpURLConnectInput(ProceedingJoinPoint joinPoint) throws Throwable { ... // 获取InputSteam，创建该InputSteam的代理，并且将代理作为结果返回 } 监听OkHttp: @Around(\u0026#34;call(* okhttp3.Dns+.lookup(..))\u0026#34;) public Object onOkHttp3DnsLookup(ProceedingJoinPoint joinPoint) throws Throwable { ... // 获取Host IP和DNS时间 } @Around(\u0026#34;call(* java.net.InetSocketAddress+.createUnresolved(..))\u0026#34;) public Object onSocketAddressResolve(ProceedingJoinPoint joinPoint) throws Throwable { ... // 获取Host IP和DNS时间 } @Around(\u0026#34;call(* okhttp3.Response.Builder+.build(..))\u0026#34;) public Object onOkHttp3RespBuild(ProceedingJoinPoint joinPoint) throws Throwable { ... // 保存Response和ResponseBody } @Around(\u0026#34;call(* okhttp3.ResponseBody+.source(..))\u0026#34;) public Object onOkHttp3RespBodySource(ProceedingJoinPoint joinPoint) throws Throwable { ... // 建立ResponseBody的代理，并把该代理作为结果返回 } 监听WebView @Around(\u0026#34;call(* android.webkit.WebView+.setWebViewClient(..))\u0026#34;) public Object onWebViewSetClient(ProceedingJoinPoint joinPoint) throws Throwable { ... // 建立WebViewClient代理，并把带监听功能的代理作为结果返回 } @Before(\u0026#34;call(* android.webkit.WebView+.loadUrl(..))\u0026#34;) public void onWebViewLoadUrl(JoinPoint joinPoint) { ... // 如果该WebView未设置WebViewClient，就给它设置监听WebViewClient } ","permalink":"https://zhongxuqi.github.io/mobile/2017-03-27/","summary":"目前市面上有很多APM厂商，用户只用集成Android SDK，写一行启动代码就可以轻松实现对APP网络请求的监听，非常神奇。本文就介绍一种可以实现该功能的技术，实现对APP网络请求的全量监听。\n需求  SDK集成后能实现对APP网络请求的监听。 接入无成本，只需要少量的启动代码，不需要修改已有的代码。  可以实现监听网络请求的技术方案 1. 实现整个http网络框架，让用户去调用。 该方案实现成本过高，而且接入成本也很高，基本不能实现。\n2. Android热修复方案 目前以Dexposed为代表的热修复方案无法支持ART虚拟机，不能用于5.0以上的Android操作系统；以Nova为代表的热修复方案需要首先被加载并且无法对修改现有类进行修改，不能用于sdk。\n3. Java AOP编程技术 该方案能成功实现对Java的Hook，而且灵活可控，能够有效实现对API的监听。\n现有Java AOP技术  Apt Aspectj Javassit  它们的区别如下图所示 本文采用Aspectj来实现网络请求监听SDK\nAndroid Aspectj插件 Android Aspectj Git Repo\n接入步骤如下所示：  关闭Android Intant Run  修改Project的.gradle文件  修改Module的.gradle文件   API Hook语法介绍 常用的annotation有Before、Around、After，分别是在目标函数(需要进行aspectj hook的函数)执行的前、中、后期进行hook。主要的hook方式分为call和execution两种，它们区别如下所示: call\n// \u0026lt;------- before call JoinPoint targetFunc() // \u0026lt;------ around call JoinPoint // \u0026lt;------- after call JoinPoint exection\ntargetFunc() {  // \u0026lt;------- before execution JoinPoint  .","title":"监听Android APP网络请求的一种方法"},{"content":"题目 一个长度为N的数组，有M(M \u0026lt; N)个插板。在每个分割方案中，每个分组和的最大值作为该分割方式的值。那么求最优方案使得值为最小\nexample input: N=[2,5,7,4,7,4], M=3\noutput 7\n动态规划思路(O(N^M)) 令状态最优函数为f(i,j,k)，含义为从第i个数到第j个放入k个插板的最优解，那个可以得出状态转移公式为\nf(i,j,k) = Min{  Max{  f(i,i,ceil(k/2) - 1),  f(i+2,j,floor(k/2))  },  ...  ,  Max{  f(i,i+x,ceil(k/2) - 1),  f(i+x+1,j,floor(k/2))  },  ...  ,  Max{  f(i,j-1,ceil(k/2) - 1),  f(j,j,floor(k/2))  } } 其中，floor(x)为小于x的最大整数，ceil(x)为大于x的最小整数。 从上可知，状态转移函数的时间复杂度为N，k的取值范围是[1, M]，所以计算复杂度为O(N^M)。\n另类思路(O(N*logN)) 先求出数组的和为sum，因此可知最优方案的取值范围是[sum/(M+1),sum]。 所以可以通过二分法查找最大值，假设初始值为(sum/(M+1) + sum) / 2 = sum * M / (M + 1) / 2。 然后把每次估计出来的最优值代入数组中验证，即从头到尾遍历一次数组，当和快超过估计值的时候，放入一个插板并把累计值置零，重新累加。 依次迭代，最终便可得出最优解。 二分法查找的复杂度为logN，每次遍历的复杂度为O(N) 因此，该方法的复杂度为O(N*logN)\n","permalink":"https://zhongxuqi.github.io/acm/2017-03-26/","summary":"题目 一个长度为N的数组，有M(M \u0026lt; N)个插板。在每个分割方案中，每个分组和的最大值作为该分割方式的值。那么求最优方案使得值为最小\nexample input: N=[2,5,7,4,7,4], M=3\noutput 7\n动态规划思路(O(N^M)) 令状态最优函数为f(i,j,k)，含义为从第i个数到第j个放入k个插板的最优解，那个可以得出状态转移公式为\nf(i,j,k) = Min{  Max{  f(i,i,ceil(k/2) - 1),  f(i+2,j,floor(k/2))  },  ...  ,  Max{  f(i,i+x,ceil(k/2) - 1),  f(i+x+1,j,floor(k/2))  },  ...  ,  Max{  f(i,j-1,ceil(k/2) - 1),  f(j,j,floor(k/2))  } } 其中，floor(x)为小于x的最大整数，ceil(x)为大于x的最小整数。 从上可知，状态转移函数的时间复杂度为N，k的取值范围是[1, M]，所以计算复杂度为O(N^M)。\n另类思路(O(N*logN)) 先求出数组的和为sum，因此可知最优方案的取值范围是[sum/(M+1),sum]。 所以可以通过二分法查找最大值，假设初始值为(sum/(M+1) + sum) / 2 = sum * M / (M + 1) / 2。 然后把每次估计出来的最优值代入数组中验证，即从头到尾遍历一次数组，当和快超过估计值的时候，放入一个插板并把累计值置零，重新累加。 依次迭代，最终便可得出最优解。 二分法查找的复杂度为logN，每次遍历的复杂度为O(N) 因此，该方法的复杂度为O(N*logN)","title":"[ACM] 求数组的最小和分割法的一种O(N*logN)思路"}]